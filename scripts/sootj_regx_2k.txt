.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp2()><java.text.MessageFormat: java.lang.Object clone()>).*<ca.mcgill.sable.soot.coffi.Instruction_Lxor: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.TypeSwitch: void caseVoidType(ca.mcgill.sable.soot.VoidType)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getDefaultTarget()>).*<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JasminClass$16: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.grimp.GArrayRef: int getPrecedence()>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.coffi.CONSTANT_String_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>).*<sun.misc.FloatingDecimal: java.lang.String toJavaFormatString()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>|<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JasminClass$3: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.NullType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<ca.mcgill.sable.soot.grimp.GrimpBody: int getLocalCount()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>).*<java.util.Arrays: char[] copyOfRange(char[],int,int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeAddress()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>|<java.io.InvalidClassException: java.lang.String getMessage()><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StmtGraph: void visitStmt(ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.jimple.VariableBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.MulExpr newMulExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.HashMap$HashEntry: int hashCode()><ca.mcgill.sable.util.AbstractList$AbstractListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.soot.jimple.Value getReturnValue()>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.Modifier: boolean isPrivate(int)>).*<ca.mcgill.sable.util.Collections$UnmodIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void <init>(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>).*<ca.mcgill.sable.soot.grimp.GAssignStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.coffi.FutureStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.IdentityStmt newIdentityStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iinc: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<java.util.jar.Manifest: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.NullConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.coffi.CFG: void buildCFG()>).*<ca.mcgill.sable.soot.coffi.Instruction_Putfield: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.AbstractExprSwitch: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void addLocal(ca.mcgill.sable.soot.jimple.Local)><ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object get(int)>).*<java.text.ParsePosition: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.coffi.cp_info: java.lang.String getTypeDescr(ca.mcgill.sable.soot.coffi.cp_info[],int)>.*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toBriefString()>.*(<java.text.DigitList: java.lang.String toString()>|<ca.mcgill.sable.soot.grimp.GInvokeStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Util: void resolveClass(ca.mcgill.sable.soot.SootClass)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.coffi.Instruction_Castore: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.util.AbstractList: int hashCode()>|<ca.mcgill.sable.soot.CharType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.TypeStack popSafe(ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.Type)>).*<java.text.AttributedCharacterIterator$Attribute: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)><ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.jimple.Local: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getPrevious()><ca.mcgill.sable.soot.Type: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>.*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseCharType(ca.mcgill.sable.soot.CharType)>.*(<java.util.HashSet: java.lang.Object clone()>|<ca.mcgill.sable.soot.LongType: void <clinit>()>)
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_byte: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.coffi.method_info: java.lang.String toName(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void copy(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction: void <init>(byte)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.Collections$UnmodList: boolean addAll(ca.mcgill.sable.util.Collection)><ca.mcgill.sable.soot.coffi.Instruction_noargs: int parse(byte[],int)>).*<ca.mcgill.sable.soot.jimple.LocalBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.jimple.JLtExpr: java.lang.String getSymbol()><ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.soot.coffi.Instruction_Land: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>.*<ca.mcgill.sable.soot.jimple.JUshrExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Int2short: void <init>()>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>)
.*<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)><ca.mcgill.sable.soot.baf.Baf: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>).*<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.StoredBody: void <init>(ca.mcgill.sable.soot.BodyRepresentation)><ca.mcgill.sable.soot.jimple.JasminClass: void print(java.io.PrintWriter)>).*<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<java.net.InterfaceAddress: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<java.net.URL: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.Modifier: java.lang.String toString(int)><java.security.AccessController: java.lang.Object doPrivileged(java.security.PrivilegedAction)>).*<ca.mcgill.sable.soot.RefType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.coffi.line_number_table_entry: void <init>()><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.coffi.local_variable_table_entry: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JNopStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JRemExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.ParameterRef: ca.mcgill.sable.util.List getUseBoxes()>).*<sun.misc.FloatingDecimal: void <init>(double)>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Local: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JasminClass$30: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.AbstractValueBox: ca.mcgill.sable.soot.jimple.Value getValue()><java.text.DigitList: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setLeft(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.IntSet: int size()><ca.mcgill.sable.soot.coffi.Instruction_byte: int parse(byte[],int)>).*<java.io.FilterInputStream: void close()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Iload: void <init>()><ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.soot.jimple.Value getBase()><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>).*<ca.mcgill.sable.soot.NoSuchFieldException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction disassemble_bytecode(byte[],int)>|<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><java.util.jar.Attributes: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ldc1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: void <init>()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$24: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: ca.mcgill.sable.util.List toList()><ca.mcgill.sable.soot.jimple.AbstractNewExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<java.io.ObjectInputStream$PeekInputStream: void close()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitBooleanBranch(java.lang.String)>|<ca.mcgill.sable.util.HashSet: ca.mcgill.sable.util.Iterator iterator()><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.MulExpr newMulExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.HashMap: boolean containsKey(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.util.LinkedList: void addFirst(java.lang.Object)><ca.mcgill.sable.soot.FloatType: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>
.*(<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)><ca.mcgill.sable.soot.jimple.AbstractExprSwitch: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void cleanupCode(ca.mcgill.sable.soot.jimple.JimpleBody)>|<java.security.Permission: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void fixDescendants(int)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmplExpr newCmplExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: void <init>()>).*<java.util.Vector: java.lang.Object elementAt(int)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.RefType: int hashCode()><ca.mcgill.sable.soot.IntType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_intindex: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Fload_3: void <init>()><ca.mcgill.sable.soot.jimple.JBreakpointStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.Modifier: boolean isProtected(int)><ca.mcgill.sable.soot.jimple.ArraySparseSet: void add(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.grimp.GSubExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()>).*<ca.mcgill.sable.util.LinkedList$Node: void setNext(ca.mcgill.sable.util.LinkedList$Node)>
.*(<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>).*<ca.mcgill.sable.soot.SootMethod: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toString()><ca.mcgill.sable.soot.Timer: void <clinit>()>).*<ca.mcgill.sable.soot.grimp.GShlExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticFieldRef newStaticFieldRef(ca.mcgill.sable.soot.SootField)><java.net.URI: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_byte: void <init>(byte)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)><java.util.zip.ZipFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void remove()>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeInt()><ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()><ca.mcgill.sable.util.LinkedList: java.lang.Object getLast()>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Castore: void <init>()><java.util.Vector: java.lang.Object clone()>).*<ca.mcgill.sable.soot.ArrayType: void <init>(ca.mcgill.sable.soot.BaseType,int)>
.*(<ca.mcgill.sable.util.Collections$UnmodList: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.LinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)><ca.mcgill.sable.soot.jimple.ArraySparseSet: void clear()>).*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.jimple.DeadCodeEliminator: void eliminateDeadCode(ca.mcgill.sable.soot.jimple.JimpleBody)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLongConstant(ca.mcgill.sable.soot.jimple.LongConstant)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore_3: void <init>()><ca.mcgill.sable.soot.jimple.JCmpgExpr: java.lang.String getSymbol()>).*<java.io.File: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.util.AbstractMap: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.grimp.GLtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String,int)>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void difference(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.soot.jimple.DoubleConstant: ca.mcgill.sable.soot.jimple.DoubleConstant v(double)>).*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.BasicBlock getEndOfBBList()><ca.mcgill.sable.soot.coffi.Instruction_Ior: void <init>()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.SootField getField()><ca.mcgill.sable.soot.baf.Baf: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>).*<java.net.NetworkInterface: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.coffi.Instruction_noargs: void <init>(byte)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()><ca.mcgill.sable.soot.ShortType: void <clinit>()>).*<java.util.Date: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ShlExpr newShlExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>).*<ca.mcgill.sable.soot.jimple.JasminClass$37: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>).*<ca.mcgill.sable.soot.jimple.ThisRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.SootField: java.lang.String getName()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getEcrIsArrayOf()>).*<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.Object getValue()>
.*<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseLongType(ca.mcgill.sable.soot.LongType)>.*(<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JCmpExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$32: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><java.math.MathContext: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.LinkedList$Node: void <init>(ca.mcgill.sable.util.LinkedList,java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: int nextOffset(int)><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.BasicBlock getEndOfBBList()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.util.ArrayList: boolean add(java.lang.Object)><ca.mcgill.sable.soot.jimple.ForwardFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_New: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.grimp.GNegExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<java.util.Vector: void removeElementAt(int)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.util.SplayTreeMap: java.lang.Object delete(java.lang.Object)>|<java.util.jar.Attributes: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.field_info: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$37: void handleIntCase()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>
.*(<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTargets(ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.coffi.Instruction_Iconst_5: void <init>()><ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.ArraySet$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()><ca.mcgill.sable.soot.Timer: long getTime()>).*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: int size()>
.*(<ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object[] toArray()>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.UnknownType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractCollection: java.lang.Object[] toArray()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void handleIntCase()><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.JUshrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.soot.jimple.StmtBody getBody()><ca.mcgill.sable.soot.BooleanType: int hashCode()>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.soot.jimple.AbstractFloatBinopExpr: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$31: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<java.util.ResourceBundle$CacheKey: java.lang.Object clone()><ca.mcgill.sable.soot.grimp.GAddExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.LongType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.IntType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dup2_x2: void <init>()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNullConstant(ca.mcgill.sable.soot.jimple.NullConstant)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack merge(ca.mcgill.sable.soot.coffi.TypeStack)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize(int)>).*<java.net.URI: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.GotoStmt newGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>).*<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ConstantAndCopyPropagator: void propagateConstantsAndCopies(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)><java.nio.charset.CoderResult: java.lang.String toString()>).*<ca.mcgill.sable.soot.SootField: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<java.net.Proxy: java.lang.String toString()><java.security.ProtectionDomain: java.lang.String toString()>).*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClassManager getManager()>
.*(<ca.mcgill.sable.soot.SootClass: int getModifiers()>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)><ca.mcgill.sable.soot.jimple.JasminClass$29: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Fdiv: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.soot.jimple.Value getBase()>).*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.grimp.GrimpBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.Timer: void <init>(java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_intvar: int parse(byte[],int)>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ArrayType: void <init>(ca.mcgill.sable.soot.BaseType,int)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void fixDescendants(int)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toString(ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_Imul: void <init>()>).*<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setTargets(ca.mcgill.sable.soot.jimple.Unit[])>|<ca.mcgill.sable.soot.NoSuperClassException: void <init>()><ca.mcgill.sable.soot.coffi.CFG: void processTargetFixup(ca.mcgill.sable.soot.coffi.BBQ)>).*<ca.mcgill.sable.util.AbstractMap$ValueCollection: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CastExpr newCastExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ThisRef newThisRef(ca.mcgill.sable.soot.SootClass)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)><ca.mcgill.sable.soot.coffi.Instruction_Fconst_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_L2f: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Lstore_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.grimp.GLeExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JGeExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.util.ConcurrentModificationException: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.util.ArrayList: java.lang.Object get(int)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>).*<ca.mcgill.sable.util.AbstractList: void <init>()>
.*(<ca.mcgill.sable.soot.LongType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ShortType: ca.mcgill.sable.soot.ShortType v()><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<java.util.zip.ZipFile: java.io.InputStream getInputStream(java.util.zip.ZipEntry)><ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GGeExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)><ca.mcgill.sable.soot.coffi.Instruction_Dreturn: void <init>()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: java.lang.String getLocalVariableName(ca.mcgill.sable.soot.coffi.cp_info[],int)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InvokeStmt newInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>).*<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void collapseStronglyConnectedComponents()>|<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()><java.io.DataInputStream: int read(byte[])>).*<java.util.Currency: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeDouble()>|<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getTargets()>).*<ca.mcgill.sable.soot.coffi.Instruction_Frem: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.FastColorer: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseCharType(ca.mcgill.sable.soot.CharType)><sun.misc.FloatingDecimal: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.ParameterRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.TypeSwitch: void caseVoidType(ca.mcgill.sable.soot.VoidType)><ca.mcgill.sable.soot.jimple.DoubleConstant: java.lang.String toString()>).*<ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object remove(java.lang.Object)>
.*(<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.OutFlow processFlow(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[])>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void handleIntCase()><ca.mcgill.sable.soot.VoidType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.NotDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<java.net.URI: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$30: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.Type: void <init>()><ca.mcgill.sable.soot.jimple.JLtExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: void set(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.coffi.Instruction_Putstatic: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.soot.jimple.Jimple: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: void setRightOp(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.UnknownType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Lshr: void <init>()><ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp2()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ThrowStmt newThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>
.*(<ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)>|<sun.misc.FDBigInt: java.lang.String toString()><ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>.*<ca.mcgill.sable.soot.jimple.JIdentityStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.coffi.Instruction_New: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>|<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>)
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)><ca.mcgill.sable.soot.LongType: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.coffi.Instruction_Bastore: void <init>()><ca.mcgill.sable.util.LinkedList: java.lang.Object removeFirst()>).*<ca.mcgill.sable.soot.grimp.GOrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseLongType(ca.mcgill.sable.soot.LongType)>|<java.util.concurrent.atomic.AtomicLong: java.lang.String toString()><ca.mcgill.sable.soot.jimple.LongConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<java.util.AbstractSet: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.Grimp: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.soot.jimple.JCmpgExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Aconst_null: void <init>()><ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.LongConstant: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GSubExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.ParameterRef: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.DoubleType: int hashCode()>
.*(<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.String toString()>|<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.TypeSwitch: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.SootClass: void resolve()>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getDefaultTarget()><ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy)>).*<ca.mcgill.sable.util.AbstractList: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ReturnVoidStmt newReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)><ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object[] toArray()>).*<ca.mcgill.sable.util.ArraySet: java.lang.Object[] access$1(ca.mcgill.sable.util.ArraySet)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>.*(<ca.mcgill.sable.util.SplayTreeMap: int compare(java.lang.Object,java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseByteType(ca.mcgill.sable.soot.ByteType)>)
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.AbstractCollection: java.lang.String toString()><ca.mcgill.sable.soot.jimple.Local: int hashCode()>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver: void error(java.lang.String)><ca.mcgill.sable.soot.jimple.StmtBox: ca.mcgill.sable.soot.jimple.Unit getUnit()>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseNullType(ca.mcgill.sable.soot.NullType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.util.AbstractMap$KeyIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.soot.jimple.Local getLocal(java.lang.String)>).*<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.Object getValue()>
.*(<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Areturn: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>).*<ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_I2l: void <init>()><java.util.AbstractSet: int hashCode()>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)><ca.mcgill.sable.soot.grimp.GrimpBody: ca.mcgill.sable.util.List getLocals()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseIntConstant(ca.mcgill.sable.soot.jimple.IntConstant)>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void eliminateBackPointersTo(ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>).*<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.coffi.Instruction_F2i: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$9: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.grimp.Grimp: void <init>()>).*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getMethods()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<java.text.AttributedCharacterIterator$Attribute: boolean equals(java.lang.Object)><ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node access$1(ca.mcgill.sable.util.SplayTreeMap)>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$34: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootField getField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.Collections$UnmodList: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JNopStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<java.io.ObjectInputStream$PeekInputStream: void close()>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: java.lang.String getLocalVariableName(ca.mcgill.sable.soot.coffi.cp_info[],int,int)><ca.mcgill.sable.soot.coffi.Instruction_I2d: void <init>()>).*<ca.mcgill.sable.util.IntSet: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.Main: java.lang.String paddedLeftOf(java.lang.String,int)>).*<ca.mcgill.sable.soot.coffi.Instruction_If_icmplt: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>).*<sun.net.www.MessageHeader: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.CharType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.Timer: void setSubstractingGC(boolean)><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getParent()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ExitMonitorStmt newExitMonitorStmt(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.SootClassManager: void addClass(ca.mcgill.sable.soot.SootClass)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: int access$0(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>).*<java.io.FilterInputStream: void close()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)><ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: float convert()>).*<ca.mcgill.sable.soot.jimple.JShlExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>|<ca.mcgill.sable.soot.jimple.JBreakpointStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: int access$0(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>
.*(<ca.mcgill.sable.soot.jimple.JIdentityStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)><ca.mcgill.sable.util.ArrayList: boolean contains(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeRef()>).*<java.io.InvalidClassException: java.lang.String getMessage()>
.*(<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int nextIndex()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CastExpr newCastExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Instruction_New: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JNopStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.util.Collections$UnmodList: boolean addAll(ca.mcgill.sable.util.Collection)><java.io.ObjectStreamClass: java.lang.String toString()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Iterator)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>.*<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void emitIntToTypeCast()>|<ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.util.List getUseBoxes()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])><ca.mcgill.sable.soot.jimple.IntConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.JMulExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy getClassHierarchy(ca.mcgill.sable.soot.SootClassManager)><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.coffi.Instruction_intbranch: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Lload_3: void <init>()><ca.mcgill.sable.soot.coffi.FutureStmt: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Fconst_1: void <init>()>
.*(<ca.mcgill.sable.soot.StmtAddressType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp2()><ca.mcgill.sable.soot.coffi.Instruction_If_icmpeq: void <init>()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.SootClass: void resolve()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newConditionExprBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.TypeSwitch: java.lang.Object getResult()>).*<ca.mcgill.sable.soot.CharType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.jimple.JAddExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.VectorSet$VectorIterator: void <init>(ca.mcgill.sable.util.VectorSet)>).*<ca.mcgill.sable.soot.jimple.JasminClass$21: void emitIntToTypeCast()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JUshrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JDivExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()><ca.mcgill.sable.soot.jimple.StmtList: boolean remove(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)>).*<ca.mcgill.sable.util.VectorSet: java.util.Vector access$0(ca.mcgill.sable.util.VectorSet)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.coffi.Instruction_Drem: void <init>()><ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String parseDesc(java.lang.String,java.lang.String)>).*<java.util.Hashtable: java.lang.Object get(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<java.util.Vector: boolean removeElement(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.SootClassManager: ca.mcgill.sable.soot.SootClass getClass(java.lang.String)>
.*<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>.*<ca.mcgill.sable.soot.SootField: java.lang.String getSignature()>.*(<ca.mcgill.sable.util.SplayTreeMap: int compare(java.lang.Object,java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseCharType(ca.mcgill.sable.soot.CharType)>)
.*<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>.*<ca.mcgill.sable.util.Collections$UnmodList: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.AbstractStmt$AllMapTo: ca.mcgill.sable.util.Collection entries()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.grimp.GLtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><java.text.MessageFormat: java.lang.Object clone()>).*<ca.mcgill.sable.soot.grimp.GLeExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.util.SplayTreeMap: int access$2(ca.mcgill.sable.util.SplayTreeMap)><ca.mcgill.sable.soot.jimple.JasminClass$37: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: void removeElementAt(int)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void dfsgt_visit(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>).*<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.coffi.Instruction_byte: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ArrayRef newArrayRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><sun.security.util.SecurityConstants: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.ParameterRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.util.ArraySet: void doubleCapacity()><ca.mcgill.sable.soot.jimple.FloatConstant: void <init>(float)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ExitMonitorStmt newExitMonitorStmt(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.util.AbstractMap$ValueCollection: int size()><java.util.concurrent.atomic.AtomicInteger: java.lang.String toString()>).*<java.util.zip.ZipEntry: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.AbstractExprSwitch: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_D2l: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.ParameterRef: void <init>(ca.mcgill.sable.soot.SootMethod,int)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.grimp.GrimpBody: void printStatementsInBody(java.io.PrintWriter,boolean)><ca.mcgill.sable.soot.coffi.Instruction_I2d: void <init>()>).*<ca.mcgill.sable.soot.jimple.JCmpgExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLongConstant(ca.mcgill.sable.soot.jimple.LongConstant)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void union(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeRef()><ca.mcgill.sable.soot.jimple.FloatConstant: ca.mcgill.sable.soot.Type getType()>).*<java.util.concurrent.locks.ReentrantLock: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: int getEcrId()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ReturnStmt newReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getIndex()>
.*(<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.BooleanType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.LongType: void apply(ca.mcgill.sable.util.Switch)>).*<java.net.Proxy: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.grimp.GInvokeStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.XorExpr newXorExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
(<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<sun.misc.FloatingDecimal: void <init>(double)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,int,int,ca.mcgill.sable.soot.jimple.UnitBox[],ca.mcgill.sable.soot.jimple.UnitBox)><ca.mcgill.sable.util.AbstractMap: int size()>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp2()>
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GLeExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass: int argCountOf(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>.*<ca.mcgill.sable.soot.SootMethod: int getParameterCount()>.*(<java.util.Date: java.lang.String toString()>|<ca.mcgill.sable.util.VectorList: int size()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.TypeResolver: void mergeBaseTypeArrays()><ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CFG: void jimpleTargetFixup()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeLong()>).*<java.util.Enumeration: boolean hasMoreElements()>
.*(<ca.mcgill.sable.soot.jimple.JIdentityStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.util.NoSuchElementException: void <init>(java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_Fadd: void <init>()>).*<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.io.ObjectStreamField: java.lang.String toString()><ca.mcgill.sable.soot.jimple.StmtList: boolean remove(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.ArrayType: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.NullType: int hashCode()>).*<java.text.DigitList: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getIndex()><ca.mcgill.sable.soot.coffi.Instruction: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.jimple.JasminClass$35: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.jimple.Jimple: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.grimp.GrimpBody: void printStatementsInBody(java.io.PrintWriter,boolean)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.Main: void <clinit>()>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.RefType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getTraps()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void addRelationsBetweenHardNodes()>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.grimp.GLtExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.SootClass getDeclaringClass()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)><ca.mcgill.sable.soot.coffi.Generic_attribute: void <init>()>).*<ca.mcgill.sable.soot.grimp.GArrayRef: int getPrecedence()>
.*(<ca.mcgill.sable.soot.jimple.AbstractUnopExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$22: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.util.AbstractCollection: void <init>()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)>.*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>.*(<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()>|<java.io.ObjectInputStream$BlockDataInputStream: void close()>)
.*<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<java.security.AllPermission: int hashCode()>|<ca.mcgill.sable.soot.jimple.FloatConstant: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.util.AbstractMap: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.jimple.ParameterRef: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><java.util.Hashtable: void <clinit>()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: ca.mcgill.sable.util.List getUnitBoxes()>|<ca.mcgill.sable.soot.jimple.SparseLiveLocals: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)><ca.mcgill.sable.soot.grimp.GrimpBody: void print_debug(java.io.PrintWriter)>).*<java.util.Vector: boolean contains(java.lang.Object)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<java.util.zip.ZipEntry: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeRef()>).*<ca.mcgill.sable.soot.coffi.Instruction_If_acmpeq: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)><ca.mcgill.sable.soot.grimp.GCmplExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.grimp.GLeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<java.net.URL: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>).*<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Instanceof: void <init>()><ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.jimple.NullConstant: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$21: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)><java.text.DecimalFormatSymbols: int hashCode()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.LinkedList: void addFirst(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ArrayRef newArrayRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>).*<ca.mcgill.sable.soot.jimple.IdentityRefBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.jimple.IntConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Iushr: void <init>()><ca.mcgill.sable.soot.StmtAddressType: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.BreakpointStmt newBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.coffi.Instruction_Lload_3: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)><ca.mcgill.sable.soot.coffi.CFG: void fixupJsrRets()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getValue()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>|<ca.mcgill.sable.soot.coffi.CFG: void prepareForGC()><ca.mcgill.sable.soot.coffi.Instruction_longbranch: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.util.AbstractMap$ValueIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: void remove(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)><ca.mcgill.sable.soot.jimple.JasminClass$20: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<java.text.DecimalFormat: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>|<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getEcrIsArrayOf()>).*<ca.mcgill.sable.soot.jimple.JimpleBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>).*<java.security.AllPermission: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>.*<ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<java.nio.charset.CoderResult: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$22: void defaultCase(ca.mcgill.sable.soot.Type)>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object setValue(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: ca.mcgill.sable.soot.RefType getBaseType()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.coffi.Instruction_byteindex: int parse(byte[],int)>).*<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String convert()><ca.mcgill.sable.soot.grimp.GTableSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Bastore: void <init>()><ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()><ca.mcgill.sable.soot.SootField: void setModifiers(int)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.IntSet: boolean get(int)><ca.mcgill.sable.soot.SootClassManager: boolean managesClass(java.lang.String)>).*<java.io.File: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.soot.SootField: void setModifiers(int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_D2f: void <init>()><ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iinc: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.IntType: java.lang.String toString()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newVariableBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: long convert()>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newVariableBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.UnknownType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: void <init>()><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>|<ca.mcgill.sable.soot.grimp.GRValueBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_intbranch: int nextOffset(int)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lstore_2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<sun.util.calendar.Era: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.ByteType: java.lang.String toString()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getKey()>
.*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toBriefString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)><ca.mcgill.sable.soot.jimple.JasminClass$27: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.SootMethod: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.coffi.Instruction_Astore_2: void <init>()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InvokeStmt newInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.jimple.JasminClass$28: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<java.nio.ByteOrder: java.lang.String toString()><ca.mcgill.sable.util.Collections$UnmodListIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toString()>|<java.util.BitSet: int size()><ca.mcgill.sable.util.Collections$UnmodListIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.jimple.LongConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.util.AbstractMap: int size()>).*<ca.mcgill.sable.util.AbstractList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<ca.mcgill.sable.soot.FloatType: int hashCode()><ca.mcgill.sable.soot.coffi.Instruction_Dstore_2: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node find(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.SparseLocalDefs: ca.mcgill.sable.util.List getDefsOfAt(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Lload_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.JSubExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.DoubleConstant: void <init>(double)>).*<java.util.jar.Manifest: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.jimple.Local getLocalForStackOp(ca.mcgill.sable.soot.jimple.JimpleBody,ca.mcgill.sable.soot.coffi.TypeStack,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>)
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.soot.jimple.JimpleBody: boolean typingFailed()>).*<ca.mcgill.sable.soot.coffi.Instruction_Baload: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>.*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Fneg: void <init>()>|<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>)
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_longbranch: void <init>(byte)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.BasicBlock: java.lang.String toString()>
.*(<ca.mcgill.sable.util.AbstractMap: boolean containsKey(java.lang.Object)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()>).*<java.util.HashMap$Entry: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.NullType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GotoStmt newGotoStmt(ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.util.ArraySet: boolean add(java.lang.Object)>|<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><java.util.zip.ZipEntry: int hashCode()>).*<ca.mcgill.sable.soot.TypeSwitch: void caseNullType(ca.mcgill.sable.soot.NullType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Newarray: int parse(byte[],int)><ca.mcgill.sable.soot.grimp.GLeExpr: java.lang.String getSymbol()>).*<java.security.CodeSource: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newIdentityRefBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.Iterator pseudoTopologicalOrderIterator()>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseRefType(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<java.util.jar.Attributes$Name: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.JasminClass$12: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: java.lang.Object next()>).*<java.math.MathContext: int hashCode()>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean loadClassFile()>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootMethod getMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iconst_4: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Main: void <clinit>()><ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.util.AbstractList: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getTarget(int)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseNullType(ca.mcgill.sable.soot.NullType)>|<ca.mcgill.sable.util.IntSet: void <init>(ca.mcgill.sable.util.IntSet)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>).*<ca.mcgill.sable.util.AbstractList: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int)>|<ca.mcgill.sable.util.IntSet: void <init>(ca.mcgill.sable.util.IntSet)><ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String parseDesc(java.lang.String,java.lang.String)>
.*<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Istore_0: void <init>()>|<ca.mcgill.sable.soot.coffi.Instruction_Jsr: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>)
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: int getPrecedence()><ca.mcgill.sable.soot.IntType: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.JasminClass$21: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.JasminClass,ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.CastExpr)><ca.mcgill.sable.soot.jimple.Local: void setName(java.lang.String)>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GeExpr newGeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><sun.util.calendar.CalendarDate: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.ConstantAndCopyPropagator: void propagateConstantsAndCopies(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void remove(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.util.LinkedList$LinkedListIterator: void add(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.FutureStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>.*(<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Return: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Aload_3: void <init>()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)><ca.mcgill.sable.soot.NoSuchFieldException: void <init>(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JasminClass$18: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.util.AbstractCollection: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.StmtBox: void <init>(ca.mcgill.sable.soot.jimple.Stmt)><java.util.HashSet: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getIndex()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.TypeStack: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.jimple.Unit getBeginUnit()>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.SootField: void setType(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Iterator)>
.*(<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.AbstractStmt: ca.mcgill.sable.util.List getBoxesPointingToThis()>).*<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: java.lang.String getLocalVariableName(ca.mcgill.sable.soot.coffi.cp_info[],int,int)><ca.mcgill.sable.soot.jimple.StmtBox: void <init>(ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)><ca.mcgill.sable.soot.coffi.Instruction_intvar: int nextOffset(int)>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*<ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)>.*(<ca.mcgill.sable.soot.StmtAddressType: int hashCode()>|<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.ListIterator listIterator()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.ClassFile: boolean readMethods(java.io.DataInputStream)>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.SootClass: void setResolved(boolean)><java.util.regex.Pattern: java.lang.String toString()>).*<ca.mcgill.sable.soot.AlreadyDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseUnknownType(ca.mcgill.sable.soot.UnknownType)>|<ca.mcgill.sable.soot.coffi.CFG: void buildCFG()><ca.mcgill.sable.soot.coffi.Instruction_Int2short: void <init>()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.Timer: void <init>()>).*<java.security.CodeSource: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>.*<ca.mcgill.sable.soot.jimple.Transformations: void cleanupCode(ca.mcgill.sable.soot.jimple.JimpleBody)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void <init>(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JasminClass$4: void caseStmtAddressType(ca.mcgill.sable.soot.StmtAddressType)>).*<ca.mcgill.sable.soot.jimple.ImmediateBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLongConstant(ca.mcgill.sable.soot.jimple.LongConstant)><ca.mcgill.sable.soot.coffi.CFG: void fixupJsrRets()>).*<ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)><java.io.InvalidClassException: java.lang.String getMessage()>).*<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClassManager getManager()><sun.util.calendar.CalendarDate: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.TableSwitchStmt newTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<java.io.DataInputStream: int readUnsignedByte()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JasminClass$13: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewArrayExpr newNewArrayExpr(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()><ca.mcgill.sable.util.AbstractCollection: boolean contains(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>
.*(<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)><ca.mcgill.sable.soot.jimple.LongConstant: ca.mcgill.sable.soot.jimple.LongConstant v(long)>).*<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$8: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>).*<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNullConstant(ca.mcgill.sable.soot.jimple.NullConstant)>|<ca.mcgill.sable.soot.jimple.LongConstant: java.lang.String toString()><java.util.Arrays: char[] copyOfRange(char[],int,int)>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>|<ca.mcgill.sable.soot.jimple.BriefStmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getTarget(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void handleIntCase()><ca.mcgill.sable.soot.jimple.JasminClass$6: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<java.security.CodeSource: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Fload_1: void <init>()>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmpExpr newCmpExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><java.math.MathContext: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.JGtExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.TypeSwitch: java.lang.Object getResult()>
.*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)>.*<ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)>.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<java.text.DigitList: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: java.lang.Object next()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>).*<ca.mcgill.sable.util.ArrayList: boolean contains(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.coffi.ClassFile: boolean readAttributes(java.io.DataInputStream,int,ca.mcgill.sable.soot.coffi.attribute_info[])><ca.mcgill.sable.soot.coffi.Instruction_Dadd: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ConcurrentModificationException: void <init>()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_Iand: void <init>()>).*<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Istore_0: void <init>()><java.util.ArrayList: java.lang.Object clone()>).*<java.util.AbstractSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()><ca.mcgill.sable.soot.jimple.TypeResolver: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>).*<ca.mcgill.sable.util.HashSet: int size()>
.*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>.*<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<java.security.CodeSigner: boolean equals(java.lang.Object)>|<ca.mcgill.sable.util.Collections$UnmodListIterator: java.lang.Object next()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.util.AbstractMap: java.lang.String toString()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Areturn: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StmtBox: ca.mcgill.sable.soot.jimple.Unit getUnit()><ca.mcgill.sable.soot.grimp.Grimp$1: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.coffi.BasicBlock: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$36: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseFloatType(ca.mcgill.sable.soot.FloatType)><java.text.NumberFormat: java.lang.String format(double)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.String toString()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LtExpr newLtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JGtExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString(java.lang.String,ca.mcgill.sable.soot.jimple.Value,java.lang.String)><ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()><ca.mcgill.sable.util.AbstractSequentialList: void <init>()>).*<ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.util.VectorSet$VectorIterator: boolean hasNext()><ca.mcgill.sable.soot.grimp.GRemExpr: java.lang.String getSymbol()>).*<java.net.NetworkInterface: int hashCode()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*(<java.util.jar.Attributes: boolean equals(java.lang.Object)>|<ca.mcgill.sable.util.AbstractMap$ValueCollection: void <init>(ca.mcgill.sable.util.AbstractMap)>)
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>.*<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>.*(<java.text.AttributedCharacterIterator$Attribute: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTarget(int,ca.mcgill.sable.soot.jimple.Unit)>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.util.Collections$UnmodListIterator: int nextIndex()>).*<ca.mcgill.sable.util.VectorSet: java.util.Vector access$0(ca.mcgill.sable.util.VectorSet)>
.*(<ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>|<ca.mcgill.sable.soot.coffi.CFG: java.lang.String getClassName(ca.mcgill.sable.soot.coffi.cp_info[],int)><ca.mcgill.sable.soot.grimp.Grimp$1: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractList: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.TypeArray: void setClassManager(ca.mcgill.sable.soot.SootClassManager)><ca.mcgill.sable.soot.jimple.BuildJimpleBodyOption: boolean noAggregating(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseNullType(ca.mcgill.sable.soot.NullType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack merge(ca.mcgill.sable.soot.coffi.TypeStack)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.Instruction_Ifnonnull: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$5: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>).*<java.util.HashMap$Entry: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<java.util.concurrent.atomic.AtomicLong: java.lang.String toString()><ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.util.Collections$UnmodIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.DoubleConstant: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.util.ArrayList: java.lang.Object remove(int)><ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)>|<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.Type jimpleReturnTypeOfInterfaceMethodRef(ca.mcgill.sable.soot.SootClassManager,ca.mcgill.sable.soot.coffi.cp_info[],int)><ca.mcgill.sable.soot.jimple.NextNextStmtRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.ArraySet$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.JIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.IntSet: boolean get(int)>).*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewExpr(ca.mcgill.sable.soot.jimple.NewExpr)><ca.mcgill.sable.soot.jimple.JasminClass$34: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_int: void <init>(byte)><ca.mcgill.sable.util.ArrayList: void doubleCapacity()>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>
.*(<ca.mcgill.sable.soot.jimple.FastColorer: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>|<ca.mcgill.sable.soot.grimp.GrimpBody: ca.mcgill.sable.soot.jimple.StmtList getStmtList()><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.BasicBlock getEndOfBBList()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()>).*<ca.mcgill.sable.util.AbstractMap$KeySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<java.util.HashMap$Entry: boolean equals(java.lang.Object)><sun.util.calendar.Era: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.LongConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.SplayTreeMap)><java.util.Locale: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Ifne: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)><ca.mcgill.sable.soot.coffi.Instruction_Fload_3: void <init>()>).*<java.util.Vector: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.coffi.Instruction_Breakpoint: void <init>()>).*<ca.mcgill.sable.soot.StmtAddressType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><java.net.URI: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JIdentityStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.TypeSwitch: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JCastExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.soot.jimple.StmtBody getBody()><ca.mcgill.sable.soot.jimple.JasminClass$1: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.SootMethod: void setModifiers(int)>
.*(<ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JasminClass$31: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>).*<ca.mcgill.sable.util.ArrayList: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.LocalSplitter: void splitLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)><ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toString()>).*<ca.mcgill.sable.util.ArraySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Hashtable$Entry: java.lang.String toString()><ca.mcgill.sable.soot.jimple.StringConstant: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.ErroneousType: ca.mcgill.sable.soot.ErroneousType v()>
.*(<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)><java.text.DecimalFormat: int hashCode()>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: int getPrecedence()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.jimple.InvokeExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.DoubleType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.DoubleType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.util.List,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.grimp.GStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LengthExpr newLengthExpr(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: boolean hasNext()>
.*<ca.mcgill.sable.soot.jimple.FastColorer: void <init>(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>.*<ca.mcgill.sable.soot.grimp.GrimpBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>.*(<ca.mcgill.sable.soot.coffi.Instruction_intindex: int nextOffset(int)>|<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object remove(int)>)
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.SootMethod: void setSource(ca.mcgill.sable.soot.coffi.ClassFile,ca.mcgill.sable.soot.coffi.method_info)>).*<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.util.List getParameterTypes()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.jimple.JLtExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.coffi.Instruction_int: void <init>(byte)>
.*(<ca.mcgill.sable.soot.SootClass: void addMethod(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JGotoStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$36: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<java.util.HashMap$Entry: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.SplayTreeMap)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.MulExpr newMulExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: boolean hasDescendant(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>
.*(<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.util.IntSet: int hashCode()><ca.mcgill.sable.soot.SootField: void setType(ca.mcgill.sable.soot.Type)>).*<java.net.URL: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticInvokeExpr newStaticInvokeExpr(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.coffi.Instruction_Ifgt: void <init>()><ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: java.lang.Object next()>).*<ca.mcgill.sable.util.LinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)><ca.mcgill.sable.soot.jimple.JasminClass$23: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Freturn: void <init>()><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.soot.jimple.ValueBox[])>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean isEcrArray()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>.*<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseShortType(ca.mcgill.sable.soot.ShortType)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.Modifier: boolean isProtected(int)><ca.mcgill.sable.soot.coffi.Instruction_If_icmpne: void <init>()>).*<java.security.Provider$Service: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Iload: void <init>()>).*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)><ca.mcgill.sable.util.TypedSplayTreeMap: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)><java.io.File: int hashCode()>).*<java.text.ParsePosition: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dconst_0: void <init>()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$36: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>).*<sun.misc.FDBigInt: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toString()><ca.mcgill.sable.soot.jimple.IntConstant: void <init>(int)>).*<ca.mcgill.sable.soot.ErroneousType: ca.mcgill.sable.soot.ErroneousType v()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.jimple.ImmediateBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object delete(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCaughtExceptionRef(ca.mcgill.sable.soot.jimple.CaughtExceptionRef)><ca.mcgill.sable.soot.TypeSwitch: void setResult(java.lang.Object)>).*<java.io.ObjectStreamField: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.AbstractUnopExpr: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.TypeSwitch: void <init>()>).*<ca.mcgill.sable.soot.SootMethod: void setModifiers(int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmplt: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$32: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.SootField: boolean isDeclared()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.coffi.LineNumberTable_attribute: void <init>()><ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object remove(int)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: void <init>()>).*<java.util.ResourceBundle$CacheKey: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_0: void <init>()><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void copy(ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: int getHighIndex()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass: void emitBooleanBranch(java.lang.String)>.*(<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.jimple.FloatConstant: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)><java.util.StringTokenizer: java.lang.Object nextElement()>).*<ca.mcgill.sable.util.HashMap$HashEntry: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: void remove(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)>|<java.util.Vector: boolean removeElement(java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Fconst_0: void <init>()>).*<java.util.jar.Attributes: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.StringConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.NullType: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<java.io.DataInputStream: void <init>(java.io.InputStream)><ca.mcgill.sable.soot.SootMethod: int getParameterCount()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.Local: void setName(java.lang.String)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.jimple.JAndExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Set keySet()>).*<ca.mcgill.sable.soot.RefType: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootField getField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.DeterministicHashMap: void <init>(int,float)><ca.mcgill.sable.soot.jimple.NullConstant: void <clinit>()>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.ListIterator listIterator()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GAddExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.Local: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.io.PrintWriter: void println(java.lang.String)><ca.mcgill.sable.util.ArraySet$ArrayIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LengthExpr newLengthExpr(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getTailJStmt()>).*<java.text.DigitList: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newVariableBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.NextNextStmtRef: ca.mcgill.sable.util.List getUseBoxes()>).*<java.util.concurrent.atomic.AtomicLong: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getMethods()>|<ca.mcgill.sable.util.LinkedList$LinkedListIterator: void set(java.lang.Object)><ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Istore_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toString()><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: java.lang.Object newInitialFlow()><ca.mcgill.sable.util.VectorList: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.jimple.JAndExpr: void apply(ca.mcgill.sable.util.Switch)><java.util.Vector: java.lang.Object clone()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JNopStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.CharType: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.Main: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)><java.util.Vector: void <init>(int,int)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Areturn: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseLongType(ca.mcgill.sable.soot.LongType)><java.net.InterfaceAddress: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: int getPrecedence()>
.*(<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GMulExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$37: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newObjExprBox(ca.mcgill.sable.soot.jimple.Value)>
.*<ca.mcgill.sable.soot.coffi.cp_info: java.lang.String getTypeDescr(ca.mcgill.sable.soot.coffi.cp_info[],int)>.*<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getNext()>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>)
.*<ca.mcgill.sable.soot.StmtAddressType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>.*(<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.Main: double truncatedOf(double,int)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.Type: ca.mcgill.sable.soot.Type merge(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.SootClassManager)>|<ca.mcgill.sable.util.HashMap: void <init>(int,float)><ca.mcgill.sable.util.AbstractMap: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.NotDeclaredException: void <init>(java.lang.String)><ca.mcgill.sable.soot.IntType: java.lang.String toString()>).*<ca.mcgill.sable.util.AbstractMap$KeySet: int size()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newObjExprBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: void <init>()>).*<ca.mcgill.sable.soot.jimple.IntConstant: void <init>(int)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.util.HashSet: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()>).*<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Map$Entry)>).*<ca.mcgill.sable.soot.coffi.Instruction_Jsr: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_byte: void <init>(byte)><ca.mcgill.sable.soot.UnknownType: void <clinit>()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)><ca.mcgill.sable.soot.SootClass: void setResolved(boolean)>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.Modifier: boolean isFinal(int)><ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction locateInst(int)>).*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.coffi.Instruction_Lload_1: void <init>()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: int size()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)><ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.Type get(int)>).*<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<sun.security.util.SecurityConstants: void <clinit>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CaughtExceptionRef newCaughtExceptionRef(ca.mcgill.sable.soot.jimple.JimpleBody)>).*<java.nio.ByteOrder: java.lang.String toString()>
.*(<ca.mcgill.sable.util.Collections$UnmodList: java.lang.String toString()>|<ca.mcgill.sable.soot.coffi.Instruction_Ifgt: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$16: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.ErroneousType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.Instruction_Monitorenter: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$29: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean loadClassFile()>|<ca.mcgill.sable.soot.coffi.Instruction_Invokevirtual: void <init>()><ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>).*<sun.misc.FloatingDecimal: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<java.io.DataInputStream: int readUnsignedShort()><ca.mcgill.sable.soot.coffi.TypeStack: boolean equals(java.lang.Object)>).*<java.util.Hashtable$Entry: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)><ca.mcgill.sable.soot.jimple.JasminClass$28: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)>
.*<ca.mcgill.sable.soot.TypeSwitch: void caseNullType(ca.mcgill.sable.soot.NullType)>.*<ca.mcgill.sable.soot.jimple.JasminClass$9: void defaultCase(ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Fload_0: void <init>()>|<java.util.Date: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void copy(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.util.AbstractMap$KeyIterator: void remove()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNullConstant(ca.mcgill.sable.soot.jimple.NullConstant)><ca.mcgill.sable.soot.jimple.JasminClass$35: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void remove()>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.NextNextStmtRef: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.SimpleLocalDefs: ca.mcgill.sable.util.List getDefsOfAt(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void collapseStronglyConnectedComponents()>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.soot.jimple.IntPair: void <init>(int,int)>).*<ca.mcgill.sable.soot.UnknownType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<java.util.zip.ZipFile: void <clinit>()><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>).*<ca.mcgill.sable.soot.grimp.GLookupSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.util.List,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.util.HashMap$HashEntry: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UshrExpr newUshrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<java.util.Vector: int size()>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_3: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$33: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseIntConstant(ca.mcgill.sable.soot.jimple.IntConstant)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.coffi.Instruction_If_acmpeq: void <init>()>).*<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)><ca.mcgill.sable.util.LinkedList: java.lang.Object getLast()>).*<ca.mcgill.sable.soot.VoidType: void <init>()>
.*(<ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.util.LinkedList: void addFirst(java.lang.Object)>).*<ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.AbstractStmt: void <clinit>()><ca.mcgill.sable.soot.coffi.Util: void setActiveClassManager(ca.mcgill.sable.soot.SootClassManager)>).*<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void addLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toString()>).*<ca.mcgill.sable.util.ArrayList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.util.TypedSplayTreeMap: java.lang.Object clone()>|<ca.mcgill.sable.soot.coffi.Utf8_Enumeration: boolean hasMoreElements()><ca.mcgill.sable.soot.jimple.JasminClass$18: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getPrevious()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.coffi.line_number_table_entry: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$18: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.grimp.GXorExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.ImmediateBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GRValueBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<java.security.AllPermission: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.Timer: void end()><ca.mcgill.sable.soot.TypeSwitch: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)><ca.mcgill.sable.soot.coffi.Instruction_L2d: void <init>()>).*<ca.mcgill.sable.soot.grimp.GMulExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$8: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.SootMethod: void setParameterTypes(ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JasminClass$27: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.ErroneousType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.IntType: void <clinit>()><java.util.BitSet: java.lang.Object clone()>).*<ca.mcgill.sable.soot.coffi.Util: void setActiveClassManager(ca.mcgill.sable.soot.SootClassManager)>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.List getExtendedBasicBlockPathBetween(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.coffi.Instruction_int: int nextOffset(int)><ca.mcgill.sable.soot.coffi.Instruction_int: int parse(byte[],int)>).*<java.io.ByteArrayInputStream: void <init>(byte[])>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)><ca.mcgill.sable.soot.jimple.StmtList: boolean remove(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_String_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalUses: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LocalDefs)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)><ca.mcgill.sable.soot.coffi.Instruction_D2l: void <init>()>).*<ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>.*<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>.*(<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.util.ArraySet$ArrayIterator: java.lang.Object next()>)
.*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.AbstractNewExpr: void <init>()>|<java.util.HashMap$Entry: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_intvar: int nextOffset(int)><ca.mcgill.sable.soot.grimp.GArrayRef: int getPrecedence()>).*<ca.mcgill.sable.soot.jimple.JasminClass$36: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>|<ca.mcgill.sable.soot.jimple.JasminClass$8: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.SootClass: void setName(java.lang.String)>).*<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><ca.mcgill.sable.soot.jimple.JasminClass$20: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseCharType(ca.mcgill.sable.soot.CharType)>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_byteindex: int parse(byte[],int)><ca.mcgill.sable.soot.jimple.IdentityRefBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.GCmpExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.IntType: void <clinit>()><ca.mcgill.sable.util.LinkedList: void access$0(ca.mcgill.sable.util.LinkedList,ca.mcgill.sable.util.LinkedList$Node)>).*<ca.mcgill.sable.util.ArraySet: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.soot.Type getCastType()><ca.mcgill.sable.soot.coffi.BBQ: ca.mcgill.sable.soot.coffi.BasicBlock pull()>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JInvokeStmt: ca.mcgill.sable.soot.jimple.Value getInvokeExpr()><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.coffi.Util: void setClassNameToAbbreviation(ca.mcgill.sable.util.Map)><ca.mcgill.sable.soot.RefType: ca.mcgill.sable.soot.RefType v(java.lang.String)>).*<java.util.Arrays: char[] copyOfRange(char[],int,int)>
.*<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<java.text.DecimalFormatSymbols: int hashCode()>|<ca.mcgill.sable.util.AbstractMap$ValueIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.soot.jimple.Value getStmtAddress()><ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getEcrIsArrayOf()><ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iconst_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Iconst_4: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>|<ca.mcgill.sable.soot.grimp.GEqExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$6: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_If_icmpne: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: void setLeftOp(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.util.HashMap: java.lang.Object get(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$2: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.util.LinkedList: java.lang.Object removeLast()>).*<ca.mcgill.sable.soot.jimple.JRetStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.util.AbstractCollection: boolean add(java.lang.Object)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newExprBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver)>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_D2f: void <init>()><ca.mcgill.sable.soot.grimp.Grimp: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.VoidType: void <clinit>()><ca.mcgill.sable.soot.NullType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: ca.mcgill.sable.soot.Type getType()>|<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.jimple.JasminClass$29: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: boolean typingFailed()>|<ca.mcgill.sable.soot.coffi.Instruction_Ifnonnull: void <init>()><ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.DoubleType: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>.*<ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.grimp.GXorExpr: java.lang.String getSymbol()>|<ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.SootClass getException()>)
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: boolean contains(java.lang.Object)>|<ca.mcgill.sable.util.IntSet: void <init>()><ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>).*<ca.mcgill.sable.util.ArraySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore_2: void <init>()><ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.Iterator iterator()>
.*<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void add(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>)
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewArrayExpr newNewArrayExpr(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<sun.security.util.SecurityConstants: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.AlreadyManagedException: void <init>(java.lang.String)><ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<java.net.InterfaceAddress: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: void intersection(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>|<ca.mcgill.sable.soot.jimple.FlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)><ca.mcgill.sable.soot.jimple.Transformations: void renameLocals(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.util.AbstractMap$KeySet: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.util.LinkedList: void <init>()><ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object remove(java.lang.Object)>).*<ca.mcgill.sable.util.LinkedList: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void dfsg_visit(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Astore_0: void <init>()>).*<java.io.ByteArrayInputStream: void <init>(byte[])>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<ca.mcgill.sable.util.LinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ShlExpr newShlExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Iterator)>
.*(<ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.XorExpr newXorExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Istore_0: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>.*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.SootField: void <init>(java.lang.String,ca.mcgill.sable.soot.Type,int)>|<ca.mcgill.sable.soot.jimple.IntPair: void <init>(int,int)>)
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)><ca.mcgill.sable.soot.NotDeclaredException: void <init>(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Lload_1: void <init>()><ca.mcgill.sable.soot.SootField: void setType(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Instruction_Goto: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)><ca.mcgill.sable.soot.jimple.JasminClass$27: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$36: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack push(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.VectorList: java.lang.Object remove(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.FastColorer: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>|<ca.mcgill.sable.soot.jimple.BuildJimpleBodyOption: boolean noCleanup(int)><ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.Object clone()>
.*(<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LtExpr newLtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.Arrays$ArrayList: int size()>
.*<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newConditionExprBox(ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NegExpr newNegExpr(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.TypeArray: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_D2f: void <init>()>
.*<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>.*(<ca.mcgill.sable.util.TypedLinkedList: void addLast(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lmul: void <init>()>
.*(<ca.mcgill.sable.soot.LongType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.ClassFile: boolean readFields(java.io.DataInputStream)><ca.mcgill.sable.util.AbstractMap$ValueIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iconst_1: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmpExpr newCmpExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.NoCast: java.lang.Object cast(java.lang.Object)>
.*(<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<java.security.Permission: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.SootField: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)><ca.mcgill.sable.util.AbstractMap$ValueIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>).*<ca.mcgill.sable.soot.coffi.SourceFile_attribute: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)><ca.mcgill.sable.soot.coffi.Instruction_Areturn: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$29: void defaultCase(ca.mcgill.sable.soot.Type)>
(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JBreakpointStmt: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.ErroneousType: ca.mcgill.sable.soot.ErroneousType v()>).*<ca.mcgill.sable.soot.grimp.ObjExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.util.ArrayList: boolean contains(java.lang.Object)>|<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getValue()><ca.mcgill.sable.util.AbstractMap: ca.mcgill.sable.util.Collection values()>).*<java.util.Vector: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: void offsetToPointer(ca.mcgill.sable.soot.coffi.ByteCode)>).*<ca.mcgill.sable.soot.jimple.LocalStmtPair: int hashCode()>
.*(<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Iinc: int parse(byte[],int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.ClassFileBody: ca.mcgill.sable.soot.SootMethod getMethod()>).*<ca.mcgill.sable.soot.jimple.GroupIntPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.coffi.Instruction_Anewarray: void <init>()><ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.jimple.NextNextStmtRef: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLongConstant(ca.mcgill.sable.soot.jimple.LongConstant)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$33: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.jimple.Constant: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.Modifier: boolean isPrivate(int)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: int getLowIndex()>).*<java.text.DecimalFormatSymbols: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.soot.grimp.GOrExpr: java.lang.String getSymbol()><ca.mcgill.sable.util.HashSet: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.ClassFile: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()><ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dneg: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.util.ArrayList: int access$0(ca.mcgill.sable.util.ArrayList)><ca.mcgill.sable.util.VectorList: java.lang.Object remove(int)>).*<java.security.AllPermission: int hashCode()>
.*<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<java.net.Inet4Address: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.coffi.Instruction_Iadd: void <init>()>)
.*(<ca.mcgill.sable.soot.SootClass: void resolve()>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Iload: void <init>()>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.SplayTreeMap)><ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<java.util.BitSet: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.AlreadyManagedException: void <init>(java.lang.String)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dup: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.SootField: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.soot.jimple.Value getBase()>).*<java.util.jar.Attributes: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecr()>).*<java.math.BigDecimal: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GRetStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Double_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)><java.text.FieldPosition: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.SootMethod: void setReturnType(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: int getTargetCount()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseCharType(ca.mcgill.sable.soot.CharType)><java.security.PrivilegedActionException: void <init>(java.lang.Exception)>).*<ca.mcgill.sable.util.VectorSet: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.text.DecimalFormat: void <init>(java.lang.String)><ca.mcgill.sable.soot.RefType: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>
.*(<ca.mcgill.sable.soot.jimple.JIdentityStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Vector: java.lang.Object elementAt(int)><ca.mcgill.sable.soot.coffi.OutFlow: void <init>(ca.mcgill.sable.soot.coffi.TypeStack)>).*<ca.mcgill.sable.soot.SootMethod: void setSource(ca.mcgill.sable.soot.coffi.ClassFile,ca.mcgill.sable.soot.coffi.method_info)>
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.coffi.Instruction_Goto_w: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.StmtList: java.lang.Object remove(int)><ca.mcgill.sable.soot.jimple.RValueBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_intindex: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dcmpg: void <init>()><ca.mcgill.sable.soot.Modifier: boolean isAbstract(int)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.ArrayType: java.lang.String toString()>).*<java.math.BigInteger: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GrimpTransformations: void foldConstructors(ca.mcgill.sable.soot.grimp.GrimpBody)>|<ca.mcgill.sable.util.VectorList: void <init>()><java.util.BitSet: boolean get(int)>).*<java.net.Inet4Address: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: int nextOffset(int)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Laload: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.soot.jimple.Value getOp()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.RefType: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JimpleBody: void addLocal(ca.mcgill.sable.soot.jimple.Local)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_NameAndType_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.CFG: void JsrEliminate()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.PrintJimpleBodyOption: boolean useAbbreviations(int)>
.*(<ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction disassemble_bytecode(byte[],int)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void difference(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Putstatic: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.util.VectorSet: boolean add(java.lang.Object)><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.grimp.GUshrExpr: java.lang.String getSymbol()>)
.*(<ca.mcgill.sable.soot.jimple.JAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)><ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>|<ca.mcgill.sable.soot.LongType: int hashCode()><ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString(ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<java.math.MathContext: int hashCode()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>.*<ca.mcgill.sable.util.AbstractList: boolean equals(java.lang.Object)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: ca.mcgill.sable.util.Iterator iterator()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LengthExpr newLengthExpr(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$6: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$15: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)><ca.mcgill.sable.soot.coffi.Instruction_int: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)><ca.mcgill.sable.soot.grimp.GUshrExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.grimp.GCastExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.RValueBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeInt()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.SootClass: java.lang.String getName()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newInvokeExprBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ldc2: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Int2char: void <init>()><ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.grimp.AbstractGrimpIntLongBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.SootField getField()><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTargets(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.util.LinkedList$Node: void setNext(ca.mcgill.sable.util.LinkedList$Node)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getCheckType()><java.util.Vector: void addElement(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)><java.io.ByteArrayInputStream: void close()>).*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.Type: ca.mcgill.sable.soot.Type merge(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.SootClassManager)>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getInterfaces()><ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Saload: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.ClassFile: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.UnknownType: void <init>()>)
.*<ca.mcgill.sable.soot.jimple.TypeResolver: void collapseStronglyConnectedComponents()>.*<ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()>.*(<ca.mcgill.sable.util.Collections$UnmodListIterator: void <init>(ca.mcgill.sable.util.ListIterator)>|<ca.mcgill.sable.util.NoCast: java.lang.Object cast(java.lang.Object)>)
.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>.*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InstanceFieldRef newInstanceFieldRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)>|<ca.mcgill.sable.soot.jimple.JAddExpr: java.lang.String getSymbol()>)
.*(<ca.mcgill.sable.soot.DoubleType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.IntSet: void set(int)><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_0: void <init>()><ca.mcgill.sable.soot.jimple.JLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iaload: void <init>()>
.*(<ca.mcgill.sable.soot.SootMethod: void addException(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.AbstractStmt$AllMapTo: ca.mcgill.sable.util.Collection entries()><ca.mcgill.sable.soot.jimple.ParameterRef: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.util.LinkedList$Node: void setNext(ca.mcgill.sable.util.LinkedList$Node)>
.*(<ca.mcgill.sable.soot.SootClass: void addField(ca.mcgill.sable.soot.SootField)>|<ca.mcgill.sable.soot.coffi.Instruction_Checkcast: void <init>()><ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.util.IntSet: void or(ca.mcgill.sable.util.IntSet)><ca.mcgill.sable.soot.jimple.JasminClass$20: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.jimple.LongConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GAddExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.grimp.GrimpBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.grimp.GIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$24: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ldc1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.FlowUniverse: void <init>(java.lang.Object[])>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClassManager getManager()><ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize()>).*<ca.mcgill.sable.util.AbstractMap$KeySet: int size()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*(<ca.mcgill.sable.soot.coffi.Instruction_int: int parse(byte[],int)>|<ca.mcgill.sable.soot.Timer: void <init>()>)
.*(<ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()><java.net.URL: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.SplayTreeMap: int access$0(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize(int)><ca.mcgill.sable.soot.jimple.JasminClass$37: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>
.*(<ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object setValue(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack pop()><ca.mcgill.sable.soot.jimple.JInvokeStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.StmtAddressType: java.lang.String toString()><java.text.ParsePosition: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.Body getBody(ca.mcgill.sable.soot.BodyRepresentation)>|<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.soot.SootMethod getMethod()><ca.mcgill.sable.util.LinkedList$LinkedListIterator: boolean hasNext()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateConstrains()>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)><java.util.HashMap: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.StaticFieldRef: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.UnitBox[],ca.mcgill.sable.soot.jimple.UnitBox)><java.util.HashMap$Entry: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.StmtBox: void setUnit(ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.soot.jimple.Stmt getTarget()>).*<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArrayList: java.lang.Object set(int,java.lang.Object)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeAddress()>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.IntType: void <init>()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[] getEcrChildren()>).*<java.util.HashMap$Entry: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>.*(<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: ca.mcgill.sable.util.List getDefBoxes()>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>)
.*(<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InstanceFieldRef newInstanceFieldRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)><ca.mcgill.sable.util.AbstractMap: ca.mcgill.sable.util.Collection values()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>).*<ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.soot.jimple.Value getCondition()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>.*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.CmpgExpr newCmpgExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>.*(<ca.mcgill.sable.soot.jimple.AbstractExprSwitch: void <init>()>|<ca.mcgill.sable.soot.grimp.Grimp: void <clinit>()>)
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>.*<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.coffi.Instruction_L2d: void <init>()>|<java.net.SocketPermission: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<java.io.DataInputStream: void <init>(java.io.InputStream)><java.util.AbstractMap: java.lang.String toString()>).*<java.math.BigInteger: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.FloatConstant: void <init>(float)><ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>).*<ca.mcgill.sable.soot.coffi.TypeArray: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.regex.PatternSyntaxException: java.lang.String getMessage()><ca.mcgill.sable.soot.jimple.JasminClass$35: void handleIntCase()>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseIntType(ca.mcgill.sable.soot.IntType)>)
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>.*(<ca.mcgill.sable.soot.BuildBody: void <init>(ca.mcgill.sable.soot.BodyRepresentation,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Iastore: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList,boolean)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getEcrIsArrayOf()><ca.mcgill.sable.soot.coffi.Double2ndHalfType: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node find(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GLookupSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.util.List,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Collection)>).*<ca.mcgill.sable.soot.jimple.StmtList: boolean remove(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.util.ArrayList: void add(int,java.lang.Object)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewArrayExpr newNewArrayExpr(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.jimple.JMulExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>).*<ca.mcgill.sable.soot.coffi.Instruction_F2d: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JGotoStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)>|<java.io.FileOutputStream: void close()><java.net.NetworkInterface: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.StmtBox: void setUnit(ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void mergeBaseTypeArrays()>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: void access$2(ca.mcgill.sable.soot.TrustingMonotonicArraySet,int)><ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.NotDeclaredException: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)><ca.mcgill.sable.soot.SootClass: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>
.*(<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.BuildJimpleBodyOption: boolean noCleanup(int)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,int,int,ca.mcgill.sable.soot.jimple.UnitBox[],ca.mcgill.sable.soot.jimple.UnitBox)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_2: void <init>()>
.*(<java.util.Currency: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)><ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)>).*<java.security.PermissionCollection: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Ifle: void <init>()><ca.mcgill.sable.soot.TrustingMonotonicArraySet: void removeElementAt(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getBase()><ca.mcgill.sable.util.IntSet: void xor(ca.mcgill.sable.util.IntSet)>).*<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void handleIntCase()><ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JDivExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JGtExpr: java.lang.String getSymbol()>).*<java.net.NetworkInterface: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.Comparator getComparator()><ca.mcgill.sable.soot.jimple.JThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.CharType: ca.mcgill.sable.soot.CharType v()>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ShortType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*(<ca.mcgill.sable.soot.jimple.JasminClass: void okayEmit(java.lang.String)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>)
.*(<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><java.security.PrivilegedActionException: void <init>(java.lang.Exception)>).*<java.util.Hashtable: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.jimple.JNopStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JReturnVoidStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.SootClass: void addField(ca.mcgill.sable.soot.SootField)>
.*(<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Iload_1: void <init>()><ca.mcgill.sable.util.ArrayList: void add(int,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)><java.io.InvalidClassException: java.lang.String getMessage()>).*<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.coffi.Instruction_Dload_1: void <init>()><ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString()>).*<ca.mcgill.sable.soot.UnknownType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.jimple.StmtList: ca.mcgill.sable.soot.jimple.StmtBody getBody()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setTargets(ca.mcgill.sable.soot.jimple.Unit[])>|<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()><ca.mcgill.sable.soot.jimple.ArraySparseSet: void doubleCapacity()>).*<java.util.Hashtable: int size()>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.cp_info: void <init>()><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize(int)>).*<java.net.URI: int hashCode()>
.*(<ca.mcgill.sable.soot.SootClass: int getModifiers()>|<ca.mcgill.sable.soot.coffi.Instruction_Lsub: void <init>()><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.util.IntSet: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.TypeSwitch: void caseUnknownType(ca.mcgill.sable.soot.UnknownType)><ca.mcgill.sable.soot.coffi.ClassFile: void <init>(java.lang.String)>).*<java.util.Vector: void insertElementAt(java.lang.Object,int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)><ca.mcgill.sable.util.SplayTreeMap: void splay(ca.mcgill.sable.util.SplayTreeMap$Node)>).*<ca.mcgill.sable.soot.grimp.GAndExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<java.io.ByteArrayInputStream: void <init>(byte[])><java.util.Vector: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.util.Hashtable access$1(ca.mcgill.sable.soot.jimple.ClassHierarchy)><ca.mcgill.sable.soot.jimple.PrintJimpleBodyOption: boolean debugMode(int)>).*<ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toString()>
.*<ca.mcgill.sable.soot.RefType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toString()>.*(<java.util.jar.Manifest$FastInputStream: void close()>|<ca.mcgill.sable.util.Arrays$ArrayList: int size()>)
.*(<ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.AlreadyManagedException: void <init>(java.lang.String)><ca.mcgill.sable.soot.grimp.GInstanceFieldRef: int getPrecedence()>).*<java.util.NoSuchElementException: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)><java.text.DigitList: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.CastExpr newCastExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.util.VectorSet: int size()><ca.mcgill.sable.soot.jimple.Transformations: boolean internalAggregate(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ErroneousType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.jimple.Unit getBeginUnit()>).*<ca.mcgill.sable.util.LinkedList: void addFirst(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.List getSuccsOf(ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.jimple.ParameterRef: int getIndex()><ca.mcgill.sable.util.HashMap: void <init>(int,float)>).*<sun.util.calendar.Era: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpIntLongBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Lushr: void <init>()>).*<ca.mcgill.sable.soot.grimp.GNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Collections$UnmodIterator: void <init>(ca.mcgill.sable.util.Iterator)><ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.ExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getValue()>).*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.EnterMonitorStmt newEnterMonitorStmt(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.ArrayList: void doubleCapacity()>).*<ca.mcgill.sable.soot.jimple.JasminClass$36: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()><java.io.FileOutputStream: void <init>(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)>|<ca.mcgill.sable.soot.jimple.Local: void <init>(java.lang.String,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.SootField getField()>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.TypeSwitch: void <init>()><ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.AbstractSequentialList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<java.io.PrintStream: void println(java.lang.Object)><ca.mcgill.sable.soot.grimp.GrimpBody$2: void <init>(ca.mcgill.sable.util.HashMap)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AndExpr newAndExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.FastColorer: void <init>(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>|<ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.TypeSwitch: java.lang.Object getResult()>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.JLeExpr: java.lang.String getSymbol()><java.security.Provider$Service: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.ConditionExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.AbstractMap: java.lang.String toString()>).*<ca.mcgill.sable.soot.Type: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.CmplExpr newCmplExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Dload_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object set(int,java.lang.Object)><ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Land: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$22: void handleIntCase()><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.BasicBlock getEndOfBBList()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_0: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>).*<java.util.Vector: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.NullType: int hashCode()><ca.mcgill.sable.soot.jimple.LocalStmtPair: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.SimpleLocalUses: ca.mcgill.sable.util.List getUsesOf(ca.mcgill.sable.soot.jimple.DefinitionStmt)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.Instruction_Lxor: void <init>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ParameterRef newParameterRef(ca.mcgill.sable.soot.SootMethod,int)>).*<ca.mcgill.sable.soot.jimple.StmtValueBoxPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_intbranch: int parse(byte[],int)><ca.mcgill.sable.soot.coffi.Instruction_Ifle: void <init>()>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.ShortType: int hashCode()><ca.mcgill.sable.soot.grimp.GRValueBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void patchForTyping()>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>).*<ca.mcgill.sable.soot.ArrayType: ca.mcgill.sable.soot.ArrayType v(ca.mcgill.sable.soot.BaseType,int)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.jimple.NullConstant: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.AlreadyManagedException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.Jimple v()>).*<ca.mcgill.sable.soot.grimp.GArrayRef: int getPrecedence()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$6: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_noargs: void <init>(byte)>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><java.util.BitSet: boolean get(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)><ca.mcgill.sable.soot.baf.BafBody: void printTo(java.io.PrintWriter,int)>).*<ca.mcgill.sable.soot.jimple.AbstractFloatBinopExpr: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.StmtGraph: void visitStmt(ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object get(int)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)>|<java.util.AbstractMap: java.lang.Object clone()><java.io.ObjectInputStream$BlockDataInputStream: void close()>).*<ca.mcgill.sable.util.Arrays$ArrayList: java.lang.Object get(int)>
.*(<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*(<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.coffi.Instruction_noargs: int parse(byte[],int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$32: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.JCastExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.grimp.ObjExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_longbranch: int parse(byte[],int)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>.*(<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ReturnVoidStmt newReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.jimple.Main: void <clinit>()><ca.mcgill.sable.soot.coffi.Instruction_Astore_1: void <init>()>).*<ca.mcgill.sable.soot.grimp.GLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeAddress()><ca.mcgill.sable.soot.coffi.Instruction_I2l: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)><ca.mcgill.sable.soot.jimple.JasminClass$13: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.util.AbstractCollection: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: void <init>()>).*<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<java.io.DataInputStream: int readInt()><ca.mcgill.sable.soot.jimple.TypeResolver: void addRelationsBetweenHardNodes()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmplt: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Ret: void <init>()>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)><ca.mcgill.sable.util.Collections$UnmodListIterator: void set(java.lang.Object)>).*<java.net.SocketPermission: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>.*<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.coffi.Util: void setActiveClassManager(ca.mcgill.sable.soot.SootClassManager)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewArrayExpr newNewArrayExpr(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JNeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Nop: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.ClassFile: ca.mcgill.sable.soot.ClassFile v()><ca.mcgill.sable.soot.jimple.Main: double truncatedOf(double,int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.jimple.JGeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.ArrayList: java.lang.Object remove(int)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.LocalSplitter: void splitLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.TypeResolver: java.util.Hashtable access$0(ca.mcgill.sable.soot.jimple.TypeResolver)><ca.mcgill.sable.soot.coffi.CFG: void prepareForGC()>).*<ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArrayList: int access$0(ca.mcgill.sable.util.ArrayList)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.coffi.Instruction_Getstatic: void <init>()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ReturnVoidStmt newReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>|<java.security.Provider$Service: java.lang.String toString()><ca.mcgill.sable.soot.jimple.CopiesFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<ca.mcgill.sable.util.IntSet: void clear(int)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLongConstant(ca.mcgill.sable.soot.jimple.LongConstant)>).*<ca.mcgill.sable.soot.jimple.JCmplExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<java.util.ResourceBundle$CacheKey: java.lang.Object clone()><ca.mcgill.sable.util.LinkedList$LinkedListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.soot.jimple.Stmt getTarget()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AndExpr newAndExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object setValue(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.JasminClass$27: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.coffi.Instruction_If_acmpne: void <init>()>
.*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AssignStmt newAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*<ca.mcgill.sable.soot.grimp.GRValueBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>.*(<ca.mcgill.sable.soot.grimp.GRValueBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)><ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getTailJStmt()>).*<java.security.Permission: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JRemExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.NullType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.ClassFileBody: void printTo(java.io.PrintWriter,int)>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: int getSizeCount()>
.*(<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewExpr(ca.mcgill.sable.soot.jimple.NewExpr)><ca.mcgill.sable.soot.coffi.Instruction_Lstore_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore: void <init>()><ca.mcgill.sable.soot.grimp.GRetStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.AbstractNewExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.EqExpr newEqExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>.*(<ca.mcgill.sable.soot.coffi.Instruction: int getInt(byte[],int)>|<ca.mcgill.sable.soot.coffi.Instruction_Dstore: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.JLtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction locateInst(int)>).*<ca.mcgill.sable.soot.UnknownType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.SootClass: void addMethod(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Trap newTrap(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.TableSwitchStmt newTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>).*<ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void handleIntCase()>
.*<ca.mcgill.sable.soot.jimple.ConstantAndCopyPropagator: void propagateConstantsAndCopies(ca.mcgill.sable.soot.jimple.StmtBody)>.*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toBriefString()>.*(<java.util.Vector: int size()>|<ca.mcgill.sable.soot.grimp.ObjExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ClassFile: void <init>()><ca.mcgill.sable.soot.jimple.FloatConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.FloatType: ca.mcgill.sable.soot.FloatType v()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void intersection(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.soot.SootClass: void setResolved(boolean)>).*<java.security.Provider$ServiceKey: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.DuplicateNameException: void <init>(java.lang.String)><java.util.Hashtable: int hashCode()>).*<ca.mcgill.sable.util.TypedLinkedList: void addFirst(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddParent(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>).*<ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.soot.jimple.Value getBase()>
.*(<ca.mcgill.sable.soot.SootClass: void setModifiers(int)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)><java.util.Vector: void insertElementAt(java.lang.Object,int)>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.grimp.GCmpgExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><sun.util.calendar.Era: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction locateInst(int)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.IllegalTypeMergeException: void <init>(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$34: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$9: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver)><ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void <init>(ca.mcgill.sable.util.AbstractList,int)>
(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.util.Arrays$ArrayList: int size()><ca.mcgill.sable.soot.jimple.JasminClass$18: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.jimple.JasminClass$21: void emitIntToTypeCast()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Goto_w: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Jsr_w: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.TypeStack smartPush(ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.AbstractCollection: boolean containsAll(ca.mcgill.sable.util.Collection)>).*<ca.mcgill.sable.util.ArrayList: void removeElementAt(int)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.ClassFile: boolean readMethods(java.io.DataInputStream)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractCastExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lushr: void <init>()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.Type getType()>|<java.security.AllPermission: int hashCode()>)
.*(<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>|<java.net.Proxy: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.TypeSwitch: java.lang.Object getResult()>).*<java.net.Proxy: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNullConstant(ca.mcgill.sable.soot.jimple.NullConstant)><java.io.ByteArrayInputStream: void close()>).*<java.net.InetAddress: int hashCode()>
.*(<ca.mcgill.sable.soot.SootClass: int getModifiers()>|<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.attribute_info: void <init>()>).*<ca.mcgill.sable.soot.AlreadyDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.CmpgExpr newCmpgExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JAndExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.StringConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.IntSet: void set(int)><ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: boolean hasDescendant(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Getfield: void <init>()><ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dload: void <init>()>
.*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()>.*<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>.*(<ca.mcgill.sable.soot.jimple.StmtBox: ca.mcgill.sable.soot.jimple.Unit getUnit()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getSizes()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Transformations: void removeUnusedLocals(ca.mcgill.sable.soot.jimple.StmtBody)><ca.mcgill.sable.soot.FloatType: ca.mcgill.sable.soot.FloatType v()>).*<ca.mcgill.sable.soot.TypeSwitch: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.IfStmt newIfStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>|<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.UnitBox)><ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.jimple.JArrayRef: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JXorExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.SootMethod: void setModifiers(int)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object get(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.coffi.line_number_table_entry: void <init>()><ca.mcgill.sable.soot.jimple.DoubleConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.util.IntSet: void clear(int)>
.*(<ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.UnusuableType: java.lang.String toString()><ca.mcgill.sable.util.AbstractSet: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.coffi.Instruction_Int2short: void <init>()><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object insert(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GShrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>|<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)><ca.mcgill.sable.soot.grimp.AbstractGrimpIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.GOrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.ClassFile: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.soot.jimple.JInstanceFieldRef: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.coffi.Instruction_Dload_2: void <init>()><sun.util.calendar.CalendarDate: int hashCode()>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ReturnVoidStmt newReturnVoidStmt()><ca.mcgill.sable.soot.coffi.Instruction_Goto_w: void <init>()>).*<ca.mcgill.sable.util.ArraySet: int access$0(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.HashSet: java.lang.Object clone()><java.math.BigDecimal: int hashCode()>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)><ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()>).*<ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.soot.jimple.Value getCondition()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.UshrExpr newUshrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Dload_0: void <init>()>).*<ca.mcgill.sable.soot.coffi.Exception_attribute: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.jimple.JasminClass$12: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.jimple.FastColorer$InterferenceGraph: void setInterference(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Local)><ca.mcgill.sable.util.Collections$UnmodListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)><ca.mcgill.sable.soot.ClassFile: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)><java.io.PrintWriter: void flush()>).*<ca.mcgill.sable.util.ArraySet: void doubleCapacity()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: void intersection(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.util.Collections$UnmodIterator: void remove()>).*<ca.mcgill.sable.util.SplayTreeMap: int access$0(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.soot.jimple.Value getStmtAddress()><java.text.DecimalFormat: java.lang.Object clone()>).*<ca.mcgill.sable.soot.grimp.GNewArrayExpr: int getPrecedence()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.util.AbstractCollection: boolean containsAll(ca.mcgill.sable.util.Collection)>).*<ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<java.security.ProtectionDomain: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$27: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.DuplicateNameException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getIndex()><ca.mcgill.sable.util.NoCast: java.lang.Object cast(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.JRetStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StringConstant: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.coffi.CONSTANT_Double_info: void <init>()>).*<ca.mcgill.sable.soot.SootClass: void addInterface(ca.mcgill.sable.soot.SootClass)>
.*(<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLongConstant(ca.mcgill.sable.soot.jimple.LongConstant)>).*<ca.mcgill.sable.soot.ByteType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>|<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.util.List getExceptions()><ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.AbstractFloatBinopExpr: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootField getField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.coffi.Instruction_byteindex: int nextOffset(int)><ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClassManager getManager()>).*<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object get(int)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.coffi.Instruction_Lshr: void <init>()><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.jimple.JCmpgExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: int getSizeCount()><ca.mcgill.sable.soot.coffi.Double2ndHalfType: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void handleIntCase()><ca.mcgill.sable.soot.jimple.JasminClass$24: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<java.io.ObjectStreamField: void <init>(java.lang.String,java.lang.Class)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)><ca.mcgill.sable.soot.coffi.Instruction_Fcmpg: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_F2d: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$31: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[] getEcrParents()>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.util.AbstractMap$ValueCollection: int size()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ldc1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$33: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: ca.mcgill.sable.soot.jimple.Value getRightOp()>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.Iterator pseudoTopologicalOrderIterator()>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)><sun.util.calendar.CalendarDate: boolean equals(java.lang.Object)>).*<java.util.Vector: java.lang.Object elementAt(int)>
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArrayList: int access$0(ca.mcgill.sable.util.ArrayList)><ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String,java.lang.String)>).*<ca.mcgill.sable.util.ArrayList: java.lang.Object[] access$1(ca.mcgill.sable.util.ArrayList)>
.*(<ca.mcgill.sable.soot.jimple.JNopStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GArrayRef: int getPrecedence()><ca.mcgill.sable.soot.jimple.JasminClass$11: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<java.text.DigitList: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.FutureStmt: void <init>()><ca.mcgill.sable.soot.jimple.JGtExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.StmtAddressType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_I2l: void <init>()><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootField)>).*<ca.mcgill.sable.util.ArraySet: void doubleCapacity()>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.soot.jimple.StmtBody getBody()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object previous()><ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_Return: void <init>()>).*<java.util.Vector: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeException: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>
.*(<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticFieldRef newStaticFieldRef(ca.mcgill.sable.soot.SootField)><ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.GInvokeStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ldc2w: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Ifgt: void <init>()><java.net.URISyntaxException: java.lang.String getMessage()>).*<ca.mcgill.sable.soot.SootClass: void resolve()>
.*(<ca.mcgill.sable.soot.SootClassManager: void addClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_3: void <init>()><ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.UnitBox)>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object get(int)><ca.mcgill.sable.soot.jimple.ArraySparseSet: void union(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: ca.mcgill.sable.soot.jimple.Value getRightOp()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)><ca.mcgill.sable.soot.jimple.JasminClass$29: void handleIntCase()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Dconst_1: void <init>()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getLeft()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: boolean hasNext()>).*<ca.mcgill.sable.util.AbstractMap$ValueCollection: int size()>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String toFormattedString(double)>|<ca.mcgill.sable.util.VectorList: java.lang.Object remove(int)><ca.mcgill.sable.util.SplayTreeMap$EntryIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.VariableBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseVoidType(ca.mcgill.sable.soot.VoidType)><ca.mcgill.sable.soot.jimple.JasminClass$31: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.coffi.Instruction_Iflt: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$29: void handleIntCase()>).*<java.util.Hashtable: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Hashtable: int hashCode()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dload_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.AbstractIntLongBinopExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp1()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.coffi.Instruction_Instanceof: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$20: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.coffi.SourceFile_attribute: void <init>()>
.*<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getHeadJStmt()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.ErroneousType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$33: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()>
(<ca.mcgill.sable.soot.SootField: java.lang.String getDeclaration()>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.FloatConstant: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: void setBase(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toString()>.*(<sun.misc.FloatingDecimal: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.soot.jimple.Stmt getTarget()>)
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>.*(<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>)
.*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.util.AbstractMap: java.lang.String toString()>.*(<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getKey()>|<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.util.AbstractMap$AbstractEntry: void <init>()>).*<java.io.ByteArrayInputStream: void <init>(byte[])>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)>|<ca.mcgill.sable.soot.coffi.CFG: void buildCFG()><java.util.Hashtable: int hashCode()>).*<java.math.BigInteger: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ExitMonitorStmt newExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)><ca.mcgill.sable.soot.coffi.Instruction_Caload: void <init>()>).*<ca.mcgill.sable.soot.Timer: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JGtExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)><ca.mcgill.sable.soot.coffi.Instruction_Pop: void <init>()>).*<java.util.AbstractMap: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.coffi.CFG: void jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewArrayExpr newNewArrayExpr(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GRemExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Fcmpl: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<java.util.AbstractList: boolean equals(java.lang.Object)><java.security.Provider$ServiceKey: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>.*(<ca.mcgill.sable.soot.DoubleType: void <init>()>|<ca.mcgill.sable.util.HashSet: boolean contains(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)>|<sun.net.www.MessageHeader: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<java.util.Hashtable: java.util.Enumeration keys()>
.*(<ca.mcgill.sable.soot.jimple.FastColorer: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>|<ca.mcgill.sable.soot.jimple.JReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GShlExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.LocalStmtPair: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_2: void <init>()><ca.mcgill.sable.util.HashMap$HashEntry: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.coffi.cp_info: java.lang.String getTypeDescr(ca.mcgill.sable.soot.coffi.cp_info[],int)>|<ca.mcgill.sable.util.SplayTreeMap: int compare(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$29: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<sun.util.calendar.CalendarDate: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecr()><ca.mcgill.sable.util.LinkedList$LinkedListIterator: void <init>(ca.mcgill.sable.util.LinkedList,int)>).*<ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.NoSuperClassException: void <init>()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: int getPrecedence()>|<ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: java.lang.String getLocalVariableName(ca.mcgill.sable.soot.coffi.cp_info[],int,int)>)
.*(<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>|<ca.mcgill.sable.soot.coffi.Instruction_Int2char: void <init>()><ca.mcgill.sable.soot.jimple.ArraySparseSet: void doubleCapacity()>).*<java.security.Timestamp: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>).*<ca.mcgill.sable.soot.coffi.Instruction_Istore: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)><ca.mcgill.sable.soot.SootClass: void addMethod(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.FloatConstant: ca.mcgill.sable.soot.jimple.FloatConstant v(float)><ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getNext()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.StaticInvokeExpr newStaticInvokeExpr(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.net.SocketPermission: int hashCode()><java.io.File: void <clinit>()>).*<ca.mcgill.sable.util.AbstractCollection: boolean contains(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.grimp.Grimp: void <clinit>()><ca.mcgill.sable.soot.coffi.Instruction_Daload: void <init>()>).*<java.util.Enumeration: boolean hasMoreElements()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void mergeBaseTypeArrays()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newObjExprBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.Type get(int)>).*<java.math.MathContext: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toString()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver)>).*<java.math.MathContext: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.JThrowStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.grimp.ObjExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toString()><ca.mcgill.sable.soot.grimp.Grimp: void <clinit>()>).*<ca.mcgill.sable.util.AbstractSequentialList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.util.AbstractCollection: boolean isEmpty()><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>).*<java.text.DecimalFormat: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Ladd: void <init>()><ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString(ca.mcgill.sable.util.Map,java.lang.String)>).*<java.util.Hashtable: java.util.Enumeration keys()>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String paddedLeftOf(java.lang.String,int)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.Value getKey()><ca.mcgill.sable.soot.coffi.method_info: java.lang.String toName(ca.mcgill.sable.soot.coffi.cp_info[])>).*<ca.mcgill.sable.soot.SootMethod: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ExitMonitorStmt newExitMonitorStmt(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.util.ArraySet: java.lang.Object[] access$1(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void add(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.soot.jimple.JasminClass$34: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)><ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.AbstractValueBox: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>.*(<ca.mcgill.sable.util.ArrayList: int access$0(ca.mcgill.sable.util.ArrayList)>|<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node find(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitBooleanBranch(java.lang.String)><ca.mcgill.sable.soot.grimp.GInstanceFieldRef: int getPrecedence()>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<java.util.Hashtable: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Lneg: void <init>()>).*<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.io.PrintStream: void flush()><ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: void <init>()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String convert()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.UnitBox,ca.mcgill.sable.soot.jimple.UnitBox,ca.mcgill.sable.soot.jimple.UnitBox)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>).*<ca.mcgill.sable.soot.jimple.JThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>|<java.io.InputStream: void close()><ca.mcgill.sable.soot.jimple.JasminClass$21: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.grimp.GGeExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.StmtList: java.lang.Object remove(int)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.Timer: void start()>|<ca.mcgill.sable.soot.IntType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JBreakpointStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: int previousIndex()>
.*(<ca.mcgill.sable.soot.jimple.JIdentityStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<java.util.Hashtable: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)><ca.mcgill.sable.soot.jimple.JimpleBody: void addLocal(ca.mcgill.sable.soot.jimple.Local)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void handleIntCase()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>.*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toBriefString()>.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<ca.mcgill.sable.soot.DoubleType: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.DoubleConstant: void <init>(double)><ca.mcgill.sable.soot.coffi.Instruction_Lrem: void <init>()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>
(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<java.util.ResourceBundle$CacheKey: int hashCode()><ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setDefaultTarget(ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore_0: void <init>()><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>).*<ca.mcgill.sable.soot.jimple.StmtBox: ca.mcgill.sable.soot.jimple.Unit getUnit()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.Timer: void end()><java.util.zip.ZipEntry: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.coffi.Instruction_Dload_2: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iinc: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseNullType(ca.mcgill.sable.soot.NullType)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$31: void handleIntCase()><ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.Instruction buildBasicBlock(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Checkcast: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseVoidType(ca.mcgill.sable.soot.VoidType)><ca.mcgill.sable.soot.jimple.InvokeExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitValue(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.soot.jimple.StmtBody getBody()><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseNullType(ca.mcgill.sable.soot.NullType)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LeExpr newLeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.jimple.JOrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.TypeSwitch: void <init>()>).*<ca.mcgill.sable.soot.DuplicateNameException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<java.util.Vector: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Util: void setClassNameToAbbreviation(ca.mcgill.sable.util.Map)>).*<java.util.regex.Pattern: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>).*<ca.mcgill.sable.soot.BooleanType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.ListIterator listIterator()><ca.mcgill.sable.soot.grimp.AbstractGrimpIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.grimp.GStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<sun.misc.FloatingDecimal: void <init>(double)><ca.mcgill.sable.soot.jimple.JUshrExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)>
.*(<ca.mcgill.sable.soot.SootClass: void resolve()>|<ca.mcgill.sable.soot.grimp.GCmplExpr: java.lang.String getSymbol()><ca.mcgill.sable.util.Collections$UnmodListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.Iterator pseudoTopologicalOrderIterator()>.*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toString()>.*(<ca.mcgill.sable.soot.coffi.Instruction_Iload_3: void <init>()>|<java.net.Proxy: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.FastColorer: void <init>(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>|<ca.mcgill.sable.soot.TypeSwitch: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.DeterministicHashMap: void <init>(int,float)>).*<java.math.BigInteger: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.LocalSplitter: void splitLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<ca.mcgill.sable.soot.grimp.GOrExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>).*<java.util.AbstractMap: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.UnknownType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<java.util.regex.PatternSyntaxException: java.lang.String getMessage()><ca.mcgill.sable.util.AbstractMap$ValueCollection: void <init>(ca.mcgill.sable.util.AbstractMap)>).*<ca.mcgill.sable.soot.jimple.JThrowStmt: ca.mcgill.sable.soot.jimple.Value getOp()>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StmtList: void <init>(ca.mcgill.sable.soot.jimple.StmtBody)><java.net.SocketPermission: int hashCode()>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>
.*(<ca.mcgill.sable.soot.jimple.JGotoStmt: void <init>(ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type jimpleTypeOfFieldDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewExpr(ca.mcgill.sable.soot.jimple.NewExpr)>).*<ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JNewArrayExpr: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_intbranch: int parse(byte[],int)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setLeft(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.io.FilterInputStream: void close()><ca.mcgill.sable.util.ArraySet$ArrayIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: void <init>(java.lang.Object[],int)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: java.lang.Object[] toArray()><ca.mcgill.sable.soot.jimple.StmtList: java.lang.Object remove(int)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getParent()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: void <init>()><ca.mcgill.sable.util.VectorList: void <init>()>).*<ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.soot.jimple.Value getStmtAddress()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<ca.mcgill.sable.util.IntSet: void set(int)><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.AlreadyDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>).*<ca.mcgill.sable.soot.StmtAddressType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.util.VectorList: void add(int,java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Sipush: void <init>()>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.util.HashSet: ca.mcgill.sable.util.Iterator iterator()><java.util.Currency: java.lang.String toString()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Collection)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.SimpleLocalUses: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LocalDefs)><sun.misc.SoftCache: void <init>(int)>).*<ca.mcgill.sable.soot.grimp.GRetStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void arrangeclonedBBinorder()>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)><java.nio.charset.CoderResult: java.lang.String toString()>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.ListIterator listIterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<java.util.jar.Attributes: int hashCode()><ca.mcgill.sable.soot.NullType: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Return: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseShortType(ca.mcgill.sable.soot.ShortType)><java.io.ObjectStreamClass: java.lang.String toString()>).*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>|<ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.util.SplayTreeMap: int size()>).*<ca.mcgill.sable.util.AbstractCollection: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)>|<ca.mcgill.sable.soot.coffi.Instruction: short getShort(byte[],int)><ca.mcgill.sable.soot.coffi.Instruction_Lstore_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Collection entries()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>).*<java.security.CodeSigner: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: java.lang.Object newInitialFlow()><ca.mcgill.sable.soot.coffi.CFG: void setHighestBlock(ca.mcgill.sable.soot.coffi.BasicBlock)>).*<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.SparseLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<java.net.InterfaceAddress: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>
(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_intvar: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GXorExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)>).*<ca.mcgill.sable.soot.jimple.JasminClass$31: void handleIntCase()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUseBoxes()>|<java.util.Hashtable: java.lang.String toString()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newRValueBox(ca.mcgill.sable.soot.jimple.Value)>).*<java.util.Enumeration: java.lang.Object nextElement()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.SootField getField()><ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dconst_1: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)>).*<java.util.NoSuchElementException: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InstanceFieldRef newInstanceFieldRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)>).*<ca.mcgill.sable.soot.jimple.JasminClass: int sizeOfType(ca.mcgill.sable.soot.Type)>
.*<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.IdentityStmt newIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void addTrap(ca.mcgill.sable.soot.jimple.Trap)><ca.mcgill.sable.soot.grimp.GCmplExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>|<ca.mcgill.sable.soot.grimp.GXorExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$33: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: void <init>(ca.mcgill.sable.soot.jimple.ArraySparseSet)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseFloatType(ca.mcgill.sable.soot.FloatType)>.*(<ca.mcgill.sable.util.IntSet: void grow()>|<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.Type byteCodeTypeOf(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.Instruction_Dcmpg: void <init>()>).*<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toString()>
.*(<ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>|<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>).*<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.jimple.FastColorer$InterferenceGraph: void <init>(ca.mcgill.sable.soot.jimple.FastColorer,ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.soot.jimple.LiveLocals)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void <init>(ca.mcgill.sable.soot.jimple.FlowUniverse,int[])><ca.mcgill.sable.soot.coffi.Instruction_Ishl: void <init>()>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ParameterRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.AbstractStmt: ca.mcgill.sable.util.List getUseAndDefBoxes()>).*<ca.mcgill.sable.soot.coffi.cp_info: long ints2long(long,long)>
.*(<ca.mcgill.sable.util.AbstractCollection: boolean remove(java.lang.Object)>|<ca.mcgill.sable.soot.grimp.GIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.grimp.GTableSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTargets(ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object remove(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)><ca.mcgill.sable.soot.jimple.ClassHierarchy: java.util.Vector access$0(ca.mcgill.sable.soot.jimple.ClassHierarchy)>).*<ca.mcgill.sable.soot.TypeSwitch: void setResult(java.lang.Object)>
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String getDeclaration()>|<ca.mcgill.sable.soot.coffi.CFG: void generateJimpleForCPEntry(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.UnknownType: void <init>()>).*<ca.mcgill.sable.soot.SootClass: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.CharType: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseStmtAddressType(ca.mcgill.sable.soot.StmtAddressType)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.util.VectorList: void add(int,java.lang.Object)>).*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.util.Collections$UnmodList: int size()><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void complement(ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.jimple.TypeResolver: void access$2(java.lang.String)>
.*(<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.util.HashMap: int size()><ca.mcgill.sable.soot.jimple.FloatConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.jimple.Value getBase()><ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNewExpr(ca.mcgill.sable.soot.jimple.NewExpr)>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Aaload: void <init>()><ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitValue(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString(ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.StmtAddressType: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseShortType(ca.mcgill.sable.soot.ShortType)>.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void <init>(ca.mcgill.sable.soot.jimple.ArraySparseSet)>)
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: ca.mcgill.sable.util.List getUnitBoxes()>|<ca.mcgill.sable.soot.coffi.Instruction_Dmul: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Fstore_1: void <init>()>).*<ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Collection entries()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.util.ArrayList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UnitBox newStmtBox(ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.jimple.Value getOp()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore_0: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$36: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.ErroneousType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GrimpTransformations: void foldConstructors(ca.mcgill.sable.soot.grimp.GrimpBody)>|<ca.mcgill.sable.soot.NoSuperClassException: void <init>()><ca.mcgill.sable.soot.jimple.FlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.IntType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)><ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString()>).*<java.io.File: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<java.io.File: void <clinit>()><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.Instruction buildBasicBlock(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>|<java.util.jar.Attributes$Name: int hashCode()><ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)>).*<ca.mcgill.sable.util.LinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void JsrEliminate()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newVariableBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.SootClass: void resolve()><ca.mcgill.sable.soot.StoredBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootMethod getMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UnitBox newStmtBox(ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.coffi.Instruction_Aload_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.grimp.GNeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$18: void handleIntCase()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.FlowAnalysis: java.lang.Object getFlowAfterStmt(ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.coffi.Instruction_Lushr: void <init>()>).*<ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Collection entries()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArrayList$ArrayIterator: void <init>(ca.mcgill.sable.util.ArrayList)><ca.mcgill.sable.soot.SootMethod: java.lang.String getDeclaration()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iadd: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Long2ndHalfType: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Lcmp: void <init>()>).*<java.net.InterfaceAddress: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.coffi.Code_attribute: void <init>()><ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Collection)>
.*(<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.zip.ZipFile: void <init>(java.lang.String)><java.nio.channels.FileChannel$MapMode: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Fconst_2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.soot.coffi.Instruction_Monitorexit: void <init>()><ca.mcgill.sable.soot.grimp.GXorExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newExprBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore: void <init>()><ca.mcgill.sable.util.IntSet: boolean get(int)>).*<ca.mcgill.sable.soot.coffi.Instruction_Goto: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Drem: void <init>()><ca.mcgill.sable.util.AbstractSet: boolean equals(java.lang.Object)>).*<java.io.FileInputStream: void <init>(java.io.File)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.BooleanType: ca.mcgill.sable.soot.BooleanType v()><java.net.Proxy: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Fieldref_info: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootField getField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()><ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>).*<java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)>|<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.jimple.JXorExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.util.HashSet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lsub: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<ca.mcgill.sable.soot.coffi.Instruction_Aaload: void <init>()><ca.mcgill.sable.soot.jimple.CompleteStmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList)>).*<ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getNext()>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: java.lang.Object[] access$1(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_longbranch: int parse(byte[],int)><ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String,java.lang.String)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseIntConstant(ca.mcgill.sable.soot.jimple.IntConstant)>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.ClassFile: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)><ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.grimp.ExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>)
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<sun.misc.FloatingDecimal: void <clinit>()><ca.mcgill.sable.soot.coffi.Instruction_int: void <init>(byte)>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.LinkedList$LinkedListIterator: void remove()><ca.mcgill.sable.soot.coffi.Instruction_Jsr: void <init>()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: void <init>(ca.mcgill.sable.util.ArrayList)>
.*<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.IntType: int hashCode()>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.util.ArraySet: void removeElementAt(int)>
.*<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>.*(<java.math.BigInteger: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>)
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList,boolean)>|<ca.mcgill.sable.util.VectorList: void add(int,java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>).*<ca.mcgill.sable.util.HashMap$HashEntry: void <init>(ca.mcgill.sable.util.HashMap,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.FloatConstant: java.lang.String toString()>|<ca.mcgill.sable.soot.coffi.Instruction_Fconst_1: void <init>()><java.io.FileInputStream: void close()>).*<ca.mcgill.sable.soot.grimp.GDivExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GNewArrayExpr: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.Collections$UnmodList: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.ParameterRef: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Astore: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>.*<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>|<ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getHeadJStmt()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.coffi.Instruction_Lload_0: void <init>()><ca.mcgill.sable.soot.jimple.DoubleConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore: void <init>()><ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)><ca.mcgill.sable.soot.jimple.JasminClass$24: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ladd: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void add(java.lang.Object)><ca.mcgill.sable.soot.Modifier: boolean isAbstract(int)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newIdentityRefBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>
.*(<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.TypeStack smartPush(ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Goto_w: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object remove(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Fieldref_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)><ca.mcgill.sable.soot.grimp.GAddExpr: java.lang.String getSymbol()>).*<java.security.Permission: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void defaultCase(ca.mcgill.sable.soot.Type)><java.net.Proxy: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_intbranch: int nextOffset(int)><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.SootField: void setModifiers(int)>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractMap: int hashCode()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>
.*(<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.soot.FloatType: void <init>()><java.text.MessageFormat: java.lang.Object clone()>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString(java.lang.String,ca.mcgill.sable.soot.jimple.Value,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.util.AbstractMap: java.lang.String toString()><ca.mcgill.sable.util.UnsupportedOperationException: void <init>()>).*<java.security.Timestamp: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<sun.security.util.SecurityConstants: void <clinit>()><ca.mcgill.sable.soot.jimple.SimpleLocalUses: ca.mcgill.sable.util.List getUsesOf(ca.mcgill.sable.soot.jimple.DefinitionStmt)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ParameterRef: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.FloatConstant: java.lang.String toString()>).*<ca.mcgill.sable.soot.FloatType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean add(java.lang.Object)><java.util.Vector: void <init>(int,int)>).*<ca.mcgill.sable.util.AbstractSet: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LtExpr newLtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Laload: void <init>()>
.*(<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseRefType(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.util.Collections$UnmodIterator: void <init>(ca.mcgill.sable.util.Iterator)>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.Iterator iterator()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>.*<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node find(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getDefBoxes()>)
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.coffi.LineNumberTable_attribute: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Collections$UnmodListIterator: int nextIndex()><ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Istore_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)><ca.mcgill.sable.soot.coffi.Instruction_Iadd: void <init>()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.JGotoStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.jimple.JThrowStmt: ca.mcgill.sable.soot.jimple.Value getOp()>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)><ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.util.Collections$UnmodIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: void removeElementAt(int)>
.*(<ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_New: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.grimp.GRValueBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.SootField: void setModifiers(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean loadClassFile()>|<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dadd: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.ThisRef: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.util.Collections$UnmodList: int size()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.Local: void setType(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.coffi.Instruction_Ifne: void <init>()>).*<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.util.regex.PatternSyntaxException: java.lang.String getMessage()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeException: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.soot.Type getType()>
(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()><ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.Comparator getComparator()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.AbstractIntLongBinopExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.util.ArrayList: int size()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>.*<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>.*(<java.util.ResourceBundle$CacheKey: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.SparseLiveLocals: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.soot.coffi.FutureStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_Lload_3: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCaughtExceptionRef(ca.mcgill.sable.soot.jimple.CaughtExceptionRef)>
.*(<ca.mcgill.sable.soot.jimple.JGotoStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.coffi.Utf8_Enumeration: boolean hasMoreElements()><ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GUshrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>|<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: int getPrecedence()><ca.mcgill.sable.util.ArraySet: void access$2(ca.mcgill.sable.util.ArraySet,int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.IntType: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$23: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.util.VectorList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.coffi.Instruction_Int2char: void <init>()>).*<ca.mcgill.sable.soot.NullType: ca.mcgill.sable.soot.NullType v()>
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>|<ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.UnitBox,ca.mcgill.sable.soot.jimple.UnitBox,ca.mcgill.sable.soot.jimple.UnitBox)><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void <init>(ca.mcgill.sable.soot.jimple.FlowUniverse)>).*<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.SootClass getException()><ca.mcgill.sable.soot.coffi.Instruction_Getfield: void <init>()>).*<ca.mcgill.sable.soot.ErroneousType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<java.text.DecimalFormat: int hashCode()><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTarget(int,ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.jimple.DoubleConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><ca.mcgill.sable.soot.jimple.AbstractUnopExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<java.util.Date: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.util.HashMap: java.lang.Object remove(java.lang.Object)><ca.mcgill.sable.soot.Timer: void end()>).*<java.util.Hashtable: java.lang.Object get(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.util.List,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.grimp.GInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.VectorList: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.CharType: ca.mcgill.sable.soot.CharType v()>).*<java.security.CodeSigner: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: ca.mcgill.sable.util.List getUseAndDefBoxes()>|<ca.mcgill.sable.soot.jimple.JIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)><java.net.InterfaceAddress: java.lang.String toString()>).*<ca.mcgill.sable.util.VectorSet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.Type: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>).*<ca.mcgill.sable.util.VectorList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JIdentityStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$35: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.ArrayType: int hashCode()>).*<ca.mcgill.sable.soot.LongType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)><ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack v()>).*<ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.coffi.FutureStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr newInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.jimple.Value getBase()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getKey()>
.*(<ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: void <init>()><ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.IntType: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.AbstractFloatBinopExpr: void <init>()><java.util.HashMap: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.soot.Type getCastType()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.SimpleLocalUses: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LocalDefs)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type[] jimpleTypesOfFieldOrMethodDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)>).*<ca.mcgill.sable.soot.coffi.Instruction_Baload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>|<java.util.Locale: int hashCode()><java.util.zip.ZipEntry: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.PrintJimpleBodyOption: boolean debugMode(int)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<java.util.AbstractSet: int hashCode()>
.*<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.FloatType: int hashCode()>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setTarget(int,ca.mcgill.sable.soot.jimple.Unit)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.coffi.Instruction_Dup_x2: void <init>()>).*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootMethod getMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><ca.mcgill.sable.soot.coffi.Instruction_I2l: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Dconst_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)><ca.mcgill.sable.soot.jimple.JasminClass$31: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Map$Entry)>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.AbstractSet: int hashCode()><ca.mcgill.sable.soot.ClassFile: void <init>()>).*<ca.mcgill.sable.soot.jimple.JNopStmt: void <init>()>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String parseDesc(java.lang.String,java.lang.String)>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClass getSuperClass()><ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.AbstractStmt$AllMapTo: ca.mcgill.sable.util.Collection entries()>
.*(<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void remove()>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.TypeSwitch: void <init>()>).*<ca.mcgill.sable.soot.jimple.LocalStmtPair: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*<ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.JasminClass)>|<ca.mcgill.sable.soot.SootField: void <init>(java.lang.String,ca.mcgill.sable.soot.Type,int)>)
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<java.text.DecimalFormatSymbols: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.CharType: int hashCode()>
.*(<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>).*<ca.mcgill.sable.soot.RefType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.Local newLocal(java.lang.String,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.Type getType()>).*<java.net.InetAddress: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClassManager getManager()>).*<ca.mcgill.sable.soot.coffi.Instruction_byte: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.coffi.Util: void resetEasyNames()>).*<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Dstore_0: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmpExpr newCmpExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>.*<ca.mcgill.sable.soot.jimple.StmtBox: void setUnit(ca.mcgill.sable.soot.jimple.Unit)>.*(<ca.mcgill.sable.soot.BooleanType: ca.mcgill.sable.soot.BooleanType v()>|<ca.mcgill.sable.util.Arrays$ArrayList: java.lang.Object get(int)>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()>|<ca.mcgill.sable.soot.coffi.BBQ: void <init>()><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<java.math.MathContext: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.SootMethod: void storeBody(ca.mcgill.sable.soot.BodyRepresentation,ca.mcgill.sable.soot.Body)><java.util.ResourceBundle$CacheKey: java.lang.Object clone()>).*<java.security.AccessControlContext: int hashCode()>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.List getPredsOf(ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.util.Hashtable access$1(ca.mcgill.sable.soot.jimple.ClassHierarchy)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.SparseLocalDefs: ca.mcgill.sable.util.List getDefsOfAt(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.jimple.JasminClass$1: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newConditionExprBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)><java.text.DecimalFormat: int hashCode()>).*<ca.mcgill.sable.soot.ErroneousType: ca.mcgill.sable.soot.ErroneousType v()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<java.util.Vector: boolean contains(java.lang.Object)><ca.mcgill.sable.util.ConcurrentModificationException: void <init>()>).*<ca.mcgill.sable.soot.grimp.GLtExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.Instruction_Bipush: void <init>()>).*<ca.mcgill.sable.soot.jimple.StringConstant: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.net.NetworkInterface: java.lang.String toString()><ca.mcgill.sable.soot.grimp.GArrayRef: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString(java.lang.String,ca.mcgill.sable.soot.jimple.Value,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.UshrExpr newUshrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getLeft()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.RetStmt newRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.SootClass: void <init>(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.grimp.Grimp v()>
.*(<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[] getEcrChildren()><ca.mcgill.sable.soot.jimple.StmtList: java.lang.Object remove(int)>).*<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()><ca.mcgill.sable.soot.coffi.Util: void resolveClass(ca.mcgill.sable.soot.SootClass)>).*<ca.mcgill.sable.util.SplayTreeMap: int size()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>.*<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.grimp.GAndExpr: java.lang.String getSymbol()>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseCharType(ca.mcgill.sable.soot.CharType)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.coffi.Instruction_Fdiv: void <init>()><ca.mcgill.sable.soot.coffi.ClassFile: void <init>(java.lang.String)>).*<ca.mcgill.sable.soot.StmtAddressType: ca.mcgill.sable.soot.StmtAddressType v()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)><java.io.FileInputStream: void <init>(java.io.File)>).*<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()><ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getPrevious()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.jimple.Value getBase()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><java.util.AbstractCollection: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.AbstractCollection: boolean containsAll(ca.mcgill.sable.util.Collection)><ca.mcgill.sable.soot.jimple.StringConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.Local: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)><java.util.BitSet: java.lang.Object clone()>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.util.HashSet: boolean add(java.lang.Object)>|<java.util.Vector: void insertElementAt(java.lang.Object,int)><ca.mcgill.sable.soot.grimp.GLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.ArrayPackedSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.Type getBaseType()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.util.HashSet: int size()><ca.mcgill.sable.soot.jimple.JGtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StringConstant: void <init>(java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_Invokeinterface: int parse(byte[],int)>).*<ca.mcgill.sable.soot.SootClassManager: void addClass(ca.mcgill.sable.soot.SootClass)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.NullConstant: void <clinit>()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dup_x1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Getfield: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Aconst_null: void <init>()>).*<ca.mcgill.sable.soot.jimple.StmtValueBoxPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<java.util.AbstractSet: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$35: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.util.SplayTreeMap: int size()>
.*(<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><java.text.MessageFormat: boolean equals(java.lang.Object)>).*<java.net.InterfaceAddress: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.Instruction_Sastore: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: void <init>()>).*<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GrimpBody: void print_debug(java.io.PrintWriter)><ca.mcgill.sable.util.ConcurrentModificationException: void <init>()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UshrExpr newUshrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void <init>(int,ca.mcgill.sable.soot.jimple.JasminClass,ca.mcgill.sable.soot.jimple.Local)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type jimpleReturnTypeOfMethodDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>).*<ca.mcgill.sable.soot.FloatType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LeExpr newLeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GRValueBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
.*<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toString()>.*(<java.util.Currency: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.grimp.GrimpBody: ca.mcgill.sable.util.List getUnitBoxes()><java.io.PrintWriter: void println(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseDoubleConstant(ca.mcgill.sable.soot.jimple.DoubleConstant)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<java.security.PrivilegedActionException: java.lang.String toString()><ca.mcgill.sable.soot.Modifier: boolean isInterface(int)>).*<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.EnterMonitorStmt newEnterMonitorStmt(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.StringConstant: ca.mcgill.sable.soot.jimple.StringConstant v(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$29: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.jimple.ArrayPackedSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)><ca.mcgill.sable.soot.jimple.JasminClass$31: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<java.util.ResourceBundle$CacheKey: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><java.util.Hashtable: int hashCode()>).*<ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.jimple.Local: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JReturnVoidStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_If_icmpne: void <init>()>
.*(<ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object,int)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)><ca.mcgill.sable.soot.jimple.JSubExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.RefType: java.lang.String toString()>).*<ca.mcgill.sable.util.HashMap$HashEntry: void <init>(ca.mcgill.sable.util.HashMap,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JLtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootField getField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.Main: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.ErroneousType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newExprBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.BasicBlock: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JGeExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void <init>(ca.mcgill.sable.util.TypedLinkedList,ca.mcgill.sable.util.ListIterator)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getMethods()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.String toString()>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void <init>(ca.mcgill.sable.util.TypedLinkedList,ca.mcgill.sable.util.ListIterator)><ca.mcgill.sable.soot.coffi.Instruction_byte: void <init>(byte)>).*<ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.JRemExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.JasminClass: int argCountOf(ca.mcgill.sable.soot.SootMethod)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.StmtList: ca.mcgill.sable.soot.jimple.StmtBody getBody()><ca.mcgill.sable.soot.UnknownType: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticInvokeExpr newStaticInvokeExpr(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.SootMethod: boolean isDeclared()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void set(java.lang.Object)><ca.mcgill.sable.soot.DeterministicHashMap: void <init>(int,float)>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JCmpgExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><java.util.regex.Matcher: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Ifnull: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void <init>(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Util: void setClassNameToAbbreviation(ca.mcgill.sable.util.Map)><ca.mcgill.sable.soot.jimple.JasminClass$20: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.util.ArrayList: ca.mcgill.sable.util.Iterator iterator()><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>).*<java.net.URISyntaxException: java.lang.String getMessage()>
.*<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setDefaultTarget(ca.mcgill.sable.soot.jimple.Unit)>.*(<ca.mcgill.sable.soot.Modifier: boolean isTransient(int)>|<ca.mcgill.sable.soot.BooleanType: boolean equals(java.lang.Object)>)
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>.*<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$23: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>|<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: ca.mcgill.sable.soot.jimple.Value getLeftOp()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<java.math.BigInteger: int hashCode()><ca.mcgill.sable.util.VectorSet: int size()>).*<java.io.DataInputStream: void <init>(java.io.InputStream)>
.*(<ca.mcgill.sable.soot.SootMethod: boolean isStatic()>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.jimple.JasminClass$13: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.Modifier: boolean isStatic(int)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void patchForTyping()>|<ca.mcgill.sable.soot.jimple.JXorExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.grimp.GArrayRef: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<java.util.AbstractMap: java.lang.String toString()><ca.mcgill.sable.soot.grimp.GCmpgExpr: java.lang.String getSymbol()>).*<java.io.DataInputStream: int readUnsignedShort()>
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: boolean hasAncestor(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)><ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toString()>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.FlowUniverse: void <init>(java.lang.Object[])>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ParameterRef newParameterRef(ca.mcgill.sable.soot.SootMethod,int)><ca.mcgill.sable.soot.jimple.JIdentityStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<java.util.AbstractMap: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.soot.SootMethod: void setReturnType(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.Collections$UnmodList: int size()>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)><ca.mcgill.sable.soot.jimple.StringConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: ca.mcgill.sable.soot.jimple.Value getBase()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: float convert()>).*<java.nio.ByteOrder: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.coffi.Instruction_Sipush: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getLeft()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: ca.mcgill.sable.soot.SootMethod getMethod()>|<ca.mcgill.sable.soot.jimple.AbstractValueBox: void <init>()>)
.*(<ca.mcgill.sable.util.AbstractList: boolean add(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractIntLongBinopExpr: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<java.util.Vector: void ensureCapacity(int)><ca.mcgill.sable.soot.jimple.JShrExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LengthExpr newLengthExpr(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: void <init>()><ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>).*<java.util.StringTokenizer: boolean hasMoreElements()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootField getField(java.lang.String,ca.mcgill.sable.soot.Type)>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Invokestatic: void <init>()>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Hashtable: java.util.Enumeration keys()><ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>
.*(<ca.mcgill.sable.soot.jimple.FastColorer$InterferenceGraph: void <init>(ca.mcgill.sable.soot.jimple.FastColorer,ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.soot.jimple.LiveLocals)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.CmpExpr newCmpExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Lstore_2: void <init>()>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object previous()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.AbstractStmt: ca.mcgill.sable.util.List getUseAndDefBoxes()><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int previousIndex()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>).*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize()>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap: int compare(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>).*<ca.mcgill.sable.soot.SootField: void setType(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>|<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()><ca.mcgill.sable.util.HashSet: boolean contains(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractMap: int size()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.HashMap: boolean isEmpty()><ca.mcgill.sable.soot.jimple.SparseLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)>).*<java.util.BitSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.util.jar.Attributes$Name: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$5: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>).*<ca.mcgill.sable.soot.grimp.GTableSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,int,int,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.IntSet: void xor(ca.mcgill.sable.util.IntSet)><ca.mcgill.sable.soot.DoubleType: int hashCode()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LengthExpr newLengthExpr(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getTraps()><ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.TableSwitchStmt newTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.VoidType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JAssignStmt: void setLeftOp(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$9: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getEcrTypeNode()><ca.mcgill.sable.soot.jimple.JasminClass$12: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getInterfaces()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLocal(ca.mcgill.sable.soot.jimple.Local)><java.net.URI: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)><ca.mcgill.sable.soot.VoidType: java.lang.String toString()>).*<ca.mcgill.sable.util.VectorList: int size()>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)><ca.mcgill.sable.soot.coffi.Instruction_Dup2_x2: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.SootField getField()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<java.util.ResourceBundle$CacheKey: java.lang.String toString()><ca.mcgill.sable.soot.StmtAddressType: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.AbstractStmt$AllMapTo: ca.mcgill.sable.util.Collection entries()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.SootField: void setModifiers(int)><ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$27: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.util.LinkedList$Node: void setPrevious(ca.mcgill.sable.util.LinkedList$Node)><ca.mcgill.sable.soot.jimple.NextNextStmtRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.IntConstant: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.coffi.Instruction_Invokeinterface: int nextOffset(int)>).*<ca.mcgill.sable.soot.grimp.GCmplExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newVariableBox(ca.mcgill.sable.soot.jimple.Value)>).*<java.io.ObjectStreamField: void <init>(java.lang.String,java.lang.Class)>
.*<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.jimple.JShlExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.coffi.Instruction_Lconst_0: void <init>()>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getInterfaces()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeException: void <init>()>).*<sun.misc.FloatingDecimal: void <init>(double)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>).*<ca.mcgill.sable.soot.ArrayType: int hashCode()>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTargets(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.util.VectorSet: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setTargets(ca.mcgill.sable.soot.jimple.Unit[])><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ShrExpr newShrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.RetStmt newRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)><ca.mcgill.sable.soot.jimple.SparseLiveLocals: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.List getExtendedBasicBlockPathBetween(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>).*<ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.DoubleConstant: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr newInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>.*<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>.*(<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getParent()>|<ca.mcgill.sable.soot.SootClass: boolean implementsInterface(java.lang.String)>)
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.LongConstant: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.VectorSet$VectorIterator: void remove()>).*<ca.mcgill.sable.soot.grimp.GShlExpr: java.lang.String getSymbol()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>.*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Iushr: void <init>()>|<ca.mcgill.sable.util.HashMap$HashEntry: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)><ca.mcgill.sable.soot.LongType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()>
.*<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>)
.*(<ca.mcgill.sable.soot.SootClass: void setModifiers(int)>|<ca.mcgill.sable.soot.jimple.JGtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>).*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.coffi.ClassFile: boolean readFields(java.io.DataInputStream)><ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_D2l: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>).*<java.util.jar.Manifest: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.util.ArrayList$ArrayIterator: boolean hasNext()><ca.mcgill.sable.soot.jimple.JasminClass$23: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.util.Arrays$ArrayList: int size()><ca.mcgill.sable.soot.jimple.LocalBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Long2ndHalfType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.soot.SootMethod getMethod()>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractMap: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void <init>(ca.mcgill.sable.soot.jimple.Value,int,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.JasminClass$34: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.StmtAddressType: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: int getArgCount()><ca.mcgill.sable.util.SplayTreeMap$Node: void removeChild(ca.mcgill.sable.util.SplayTreeMap$Node)>).*<ca.mcgill.sable.soot.grimp.GNeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<java.math.MathContext: java.lang.String toString()><java.io.PrintWriter: void println()>).*<ca.mcgill.sable.soot.ArrayType: void <init>(ca.mcgill.sable.soot.BaseType,int)>
.*(<ca.mcgill.sable.soot.jimple.JGotoStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.BooleanType: java.lang.String toString()><ca.mcgill.sable.soot.UnknownType: boolean equals(java.lang.Object)>).*<java.util.Vector: void insertElementAt(java.lang.Object,int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseShortType(ca.mcgill.sable.soot.ShortType)><java.util.jar.Manifest$FastInputStream: void close()>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)><ca.mcgill.sable.soot.coffi.Instruction_Astore_1: void <init>()>).*<ca.mcgill.sable.soot.SootClass: void setName(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.jimple.JasminClass$29: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>
(<ca.mcgill.sable.soot.jimple.DoubleConstant: void <init>(double)>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setLeft(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.JasminClass$12: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>).*<java.security.Provider$ServiceKey: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.util.AbstractMap$ValueCollection: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.coffi.Instruction: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JasminClass$18: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.coffi.Instruction_bytevar: void <init>(byte)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.IdentityStmt newIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)><ca.mcgill.sable.soot.VoidType: int hashCode()>).*<ca.mcgill.sable.soot.coffi.Instruction_Drem: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.List getSuccsOf(ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.jimple.JasminClass$1: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<java.net.URISyntaxException: java.lang.String getMessage()><ca.mcgill.sable.soot.jimple.ArraySparseSet: ca.mcgill.sable.util.List toList()>).*<ca.mcgill.sable.util.AbstractList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.util.IntSet: boolean get(int)><ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>
.*<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>)
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ClassFileBody: ca.mcgill.sable.soot.SootMethod getMethod()><ca.mcgill.sable.soot.jimple.Transformations: void renameLocals(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>
.*<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: void setLeftOp(ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.Timer: void <init>()><ca.mcgill.sable.soot.VoidType: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>.*<ca.mcgill.sable.soot.jimple.JThrowStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.util.Arrays$ArrayList: java.lang.Object set(int,java.lang.Object)>|<java.net.NetworkInterface: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<java.util.Hashtable: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: java.lang.Object newInitialFlow()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$21: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_3: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>.*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>.*(<ca.mcgill.sable.util.HashMap: void <init>(int,float)>|<ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.grimp.GRValueBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<java.net.InterfaceAddress: int hashCode()><ca.mcgill.sable.soot.jimple.JMulExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toString()>).*<ca.mcgill.sable.util.ArrayList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Astore_2: void <init>()><ca.mcgill.sable.soot.jimple.IntConstant: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><java.nio.ByteOrder: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>.*(<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void set(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseIntType(ca.mcgill.sable.soot.IntType)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)><ca.mcgill.sable.soot.grimp.GrimpBody: void print_debug(java.io.PrintWriter)>).*<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.ForwardFlowAnalysis: void doAnalysis()>|<ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toString(ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)><ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.DoubleType: ca.mcgill.sable.soot.DoubleType v()>).*<ca.mcgill.sable.soot.grimp.ObjExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void difference(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.FastColorer: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Map)>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getLookupValues()>
.*(<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><ca.mcgill.sable.util.TypedSplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator,ca.mcgill.sable.util.Cast,ca.mcgill.sable.util.Cast)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.util.BitSet: boolean get(int)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>).*<ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)>
.*<ca.mcgill.sable.util.AbstractCollection: boolean contains(java.lang.Object)>.*<ca.mcgill.sable.util.AbstractCollection: boolean contains(java.lang.Object)>.*(<ca.mcgill.sable.util.IntSet: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.Local: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.NextNextStmtRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.SootMethod: void addException(ca.mcgill.sable.soot.SootClass)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<sun.util.calendar.CalendarDate: int hashCode()><java.math.BigDecimal: java.lang.String toString()>).*<ca.mcgill.sable.util.SplayTreeMap: java.lang.Object delete(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr newInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void handleIntCase()><ca.mcgill.sable.soot.coffi.Instruction_I2l: void <init>()>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>|<ca.mcgill.sable.util.ArraySet: java.lang.Object[] toArray()><ca.mcgill.sable.soot.coffi.TypeArray: void setClassManager(ca.mcgill.sable.soot.SootClassManager)>).*<ca.mcgill.sable.soot.grimp.GRemExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()><ca.mcgill.sable.soot.coffi.Instruction_Faload: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Invokeinterface: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.grimp.GLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>|<ca.mcgill.sable.util.LinkedList: int size()><ca.mcgill.sable.soot.jimple.JasminClass$11: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.util.ArrayList: boolean add(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*<ca.mcgill.sable.soot.coffi.ClassFile: boolean loadClassFile()>.*(<ca.mcgill.sable.soot.coffi.Instruction_Pop2: void <init>()>|<java.net.NetworkInterface: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_D2f: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()>|<ca.mcgill.sable.soot.jimple.NullConstant: ca.mcgill.sable.soot.jimple.NullConstant v()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LeExpr newLeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.util.AbstractList: boolean add(java.lang.Object)>)
.*(<ca.mcgill.sable.util.VectorSet$VectorIterator: java.lang.Object next()>|<ca.mcgill.sable.soot.jimple.FloatConstant: void <init>(float)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<java.util.Vector: java.lang.Object elementAt(int)>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.FutureStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeFloat()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<java.util.BitSet: java.lang.Object clone()><ca.mcgill.sable.soot.SootMethod: boolean isStatic()>).*<ca.mcgill.sable.soot.coffi.Instruction_Dup2_x2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>|<ca.mcgill.sable.soot.grimp.GLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Invokevirtual: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.SimpleLiveLocals: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.util.Collections$UnmodList: boolean remove(java.lang.Object)><ca.mcgill.sable.soot.jimple.FlowUniverse: void <init>(java.lang.Object[])>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getUseBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void removeElementAt(int)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.nio.channels.FileChannel$MapMode: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.LocalCopy: java.lang.String toString()><ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.util.ArraySet: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)><ca.mcgill.sable.soot.jimple.PrintJimpleBodyOption: boolean debugMode(int)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ior: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])><ca.mcgill.sable.soot.coffi.Instruction_Astore_3: void <init>()>).*<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.util.List getExceptions()><ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.jimple.Unit getEndUnit()>).*<ca.mcgill.sable.soot.jimple.LocalCopy: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.coffi.SourceFile_attribute: void <init>()>).*<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)><java.util.ResourceBundle$CacheKey: java.lang.String toString()>).*<ca.mcgill.sable.util.ArraySet: int access$0(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.coffi.CONSTANT_NameAndType_info: void <init>()>).*<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void addRelationsBetweenHardNodes()>|<ca.mcgill.sable.soot.coffi.line_number_table_entry: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.DoubleType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.LinkedList computeOrder(boolean)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.ArrayList: ca.mcgill.sable.util.Iterator iterator()>
(<java.util.NoSuchElementException: void <init>()>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean isEcrArray()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.SootClass: boolean implementsInterface(java.lang.String)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.SootMethod: java.lang.String toString()>).*<ca.mcgill.sable.soot.NotDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.GTableSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.coffi.Instruction_Dastore: void <init>()><java.util.HashMap$Entry: java.lang.String toString()>).*<java.math.MathContext: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JGtExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JimpleBody: void eliminateBackPointersTo(ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_intindex: int nextOffset(int)><ca.mcgill.sable.soot.jimple.ArraySparseSet: void union(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)><ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getIndex()>).*<ca.mcgill.sable.soot.ErroneousType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.StmtAddressType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.ArrayList: void add(int,java.lang.Object)>).*<ca.mcgill.sable.soot.IntType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.coffi.Instruction_Iastore: void <init>()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>).*<ca.mcgill.sable.soot.grimp.GOrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass: void okayEmit(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$16: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>).*<java.net.URL: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getTraps()><ca.mcgill.sable.soot.jimple.JasminClass$1: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setLeft(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void JsrEliminate()>|<sun.misc.FloatingDecimal: void <init>(double)><ca.mcgill.sable.soot.jimple.DoubleConstant: void <init>(double)>).*<ca.mcgill.sable.soot.ByteType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$37: void handleIntCase()><ca.mcgill.sable.soot.grimp.GrimpBody: int getLocalCount()>).*<ca.mcgill.sable.soot.TypeSwitch: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<ca.mcgill.sable.util.SplayTreeMap$Node: void setLeft(ca.mcgill.sable.util.SplayTreeMap$Node)><ca.mcgill.sable.util.AbstractMap$AbstractEntry: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getUseBoxes()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<java.util.Hashtable: java.lang.Object get(java.lang.Object)><ca.mcgill.sable.util.LinkedList: java.lang.Object getFirst()>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*(<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node access$1(ca.mcgill.sable.util.SplayTreeMap)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<java.io.ObjectInputStream$PeekInputStream: void close()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.OrExpr newOrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.coffi.Instruction_F2d: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getLeft()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>.*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: ca.mcgill.sable.soot.Type getType()>.*(<ca.mcgill.sable.soot.coffi.Instruction_Dsub: void <init>()>|<ca.mcgill.sable.soot.ByteType: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Nop: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$1: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void fixDescendants(int)>
.*(<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_intindex: void <init>(byte)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ArrayRef newArrayRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.TypeSwitch: void caseErroneousType(ca.mcgill.sable.soot.ErroneousType)>).*<ca.mcgill.sable.util.ArrayList: java.lang.Object[] access$1(ca.mcgill.sable.util.ArrayList)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<sun.misc.FloatingDecimal: void <init>(double)><ca.mcgill.sable.util.LinkedList$LinkedListIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.LongType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.util.LinkedList$LinkedListIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.coffi.Instruction_Saload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CFG: int typeSize(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.ByteCode: void <init>()>).*<ca.mcgill.sable.util.VectorList: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()>|<ca.mcgill.sable.soot.coffi.Instruction: void <init>(byte)><ca.mcgill.sable.soot.jimple.JasminClass$9: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.ThisRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JGeExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.util.AbstractList: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ShortType: int hashCode()><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.Type jimpleReturnTypeOfInterfaceMethodRef(ca.mcgill.sable.soot.SootClassManager,ca.mcgill.sable.soot.coffi.cp_info[],int)>).*<ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.Comparator getComparator()>).*<java.net.Proxy: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>.*<ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object)>.*(<ca.mcgill.sable.util.LinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>|<ca.mcgill.sable.soot.jimple.DoubleConstant: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.AssignStmt newAssignStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.SootClass getException()>).*<ca.mcgill.sable.soot.jimple.IdentityRefBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.DoubleType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$36: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getBase()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<java.util.Vector: boolean removeElement(java.lang.Object)><ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JThrowStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<sun.util.calendar.Era: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$19: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.grimp.AbstractGrimpIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: float convert()><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy)>).*<ca.mcgill.sable.soot.NullType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)><ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JThrowStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.coffi.Instruction_Dup: void <init>()><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.coffi.Instruction_intindex: int parse(byte[],int)><ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.ShortType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_byteindex: int parse(byte[],int)><ca.mcgill.sable.soot.jimple.LongConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.Local: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>.*<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>.*(<java.security.CodeSource: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.soot.jimple.ValueBox[])>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.FloatConstant: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JasminClass$30: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Double_info: double convert()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void patchForTyping()>|<java.util.BitSet: void <init>()><ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.SootField getField()>).*<java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.NoSuchElementException: void <init>(java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_Ifgt: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>|<ca.mcgill.sable.soot.TypeSwitch: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>).*<ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.IdentityStmt newIdentityStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dstore_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.Type: ca.mcgill.sable.soot.Type merge(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.SootClassManager)>).*<ca.mcgill.sable.soot.RefType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><java.util.StringTokenizer: int countTokens()>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>
.*(<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CFG: void generateJimpleForCPEntry(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JBreakpointStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)>
.*(<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.coffi.Instruction_L2f: void <init>()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.EqExpr newEqExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.DoubleType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.jimple.StringConstant: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.coffi.Instruction_Ldc2w: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.jimple.JRetStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>).*<ca.mcgill.sable.soot.coffi.Instruction_Faload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.coffi.Instruction_Iinc: int nextOffset(int)><ca.mcgill.sable.soot.jimple.DoubleConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>|<sun.util.calendar.Era: boolean equals(java.lang.Object)><ca.mcgill.sable.util.ClassLocator: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.DoubleConstant: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.AbstractStmt: void <clinit>()><java.io.File: java.lang.String toString()>).*<ca.mcgill.sable.util.SplayTreeMap: int access$0(ca.mcgill.sable.util.SplayTreeMap)>
.*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>.*<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.util.Hashtable access$1(ca.mcgill.sable.soot.jimple.ClassHierarchy)>|<ca.mcgill.sable.soot.jimple.Local: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.util.Arrays$ArrayList: java.lang.Object set(int,java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.soot.jimple.JGtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.IntType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.AbstractJimpleFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object set(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.BooleanType: ca.mcgill.sable.soot.BooleanType v()><ca.mcgill.sable.util.LinkedList$Node: void setNext(ca.mcgill.sable.util.LinkedList$Node)>).*<ca.mcgill.sable.soot.jimple.VariableBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.coffi.Instruction_I2d: void <init>()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void fixDescendants(int)>
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: java.lang.Object[] access$1(ca.mcgill.sable.soot.TrustingMonotonicArraySet)><sun.misc.FloatingDecimal: void <clinit>()>).*<java.security.CodeSigner: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CastExpr newCastExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getHeadJStmt()>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newInvokeExprBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: float convert()>).*<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitBooleanBranch(java.lang.String)>|<sun.misc.FloatingDecimal: void <init>(float)><java.util.Vector: void insertElementAt(java.lang.Object,int)>).*<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()>|<ca.mcgill.sable.soot.Timer: void end()><ca.mcgill.sable.soot.jimple.JasminClass$36: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JOrExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ExitMonitorStmt newExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseNullType(ca.mcgill.sable.soot.NullType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.util.ArraySet: java.lang.Object[] access$1(ca.mcgill.sable.util.ArraySet)><ca.mcgill.sable.soot.jimple.JasminClass$30: void handleIntCase()>).*<ca.mcgill.sable.util.Collections$UnmodList: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddParent(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.jimple.DoubleConstant: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.BooleanType: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.GroupIntPair: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.Type: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>|<java.util.regex.Pattern: java.lang.String toString()><ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp2()>).*<java.util.Formatter: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toString()>.*<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object get(int)>|<java.util.jar.Attributes$Name: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.jimple.JCastExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.AbstractMap$KeyIterator: void remove()>).*<java.util.ResourceBundle$CacheKey: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.util.ArraySet: boolean add(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>.*<ca.mcgill.sable.soot.LongType: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseLongType(ca.mcgill.sable.soot.LongType)>)
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InstanceOfExpr newInstanceOfExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: java.lang.Object newInitialFlow()>).*<ca.mcgill.sable.soot.jimple.JInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Ldiv: void <init>()><ca.mcgill.sable.soot.jimple.JGtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseErroneousType(ca.mcgill.sable.soot.ErroneousType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<java.util.Date: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JasminClass$30: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.LocalStmtPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.soot.LongType: void <init>()><ca.mcgill.sable.soot.jimple.BackwardFlowAnalysis: void doAnalysis()>).*<java.io.InvalidClassException: java.lang.String getMessage()>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmple: void <init>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ineg: void <init>()>
.*(<ca.mcgill.sable.soot.SootMethod: void storeBody(ca.mcgill.sable.soot.BodyRepresentation,ca.mcgill.sable.soot.Body)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.RetStmt newRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)><ca.mcgill.sable.soot.coffi.Instruction_Dload_2: void <init>()>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JAssignStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>.*(<ca.mcgill.sable.soot.coffi.Instruction_bytevar: int parse(byte[],int)>|<ca.mcgill.sable.soot.jimple.ParameterRef: java.lang.String toString()>)
.*<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>.*<ca.mcgill.sable.soot.coffi.ClassFile: boolean readConstantPool(java.io.DataInputStream)>.*(<ca.mcgill.sable.soot.jimple.ImmediateBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JShlExpr: java.lang.String getSymbol()>)
.*<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>.*(<ca.mcgill.sable.soot.jimple.AbstractUnopExpr: ca.mcgill.sable.soot.jimple.Value getOp()>|<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()>)
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String toFormattedString(double)>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)><ca.mcgill.sable.soot.coffi.TypeStack: int topIndex()>).*<ca.mcgill.sable.util.SplayTreeMap: void splay(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getSizes()><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_byte: int nextOffset(int)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: int getLowIndex()>|<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>)
.*(<ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ThisRef newThisRef(ca.mcgill.sable.soot.SootClass)>).*<ca.mcgill.sable.soot.coffi.Instruction_I2d: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)><ca.mcgill.sable.soot.jimple.JIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.SootClassManager: void addClass(ca.mcgill.sable.soot.SootClass)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<ca.mcgill.sable.soot.coffi.Double2ndHalfType: ca.mcgill.sable.soot.coffi.Double2ndHalfType v()><ca.mcgill.sable.soot.Modifier: boolean isPublic(int)>).*<ca.mcgill.sable.soot.jimple.AbstractNewExpr: ca.mcgill.sable.soot.RefType getBaseType()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver: java.util.Hashtable access$0(ca.mcgill.sable.soot.jimple.TypeResolver)><ca.mcgill.sable.soot.TypeSwitch: void caseStmtAddressType(ca.mcgill.sable.soot.StmtAddressType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<java.util.Vector: java.util.Enumeration elements()><ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>
.*(<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type jimpleReturnTypeOfMethodDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)><ca.mcgill.sable.soot.jimple.AbstractNewExpr: void <init>()>).*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.String toString()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmplExpr newCmplExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.LongType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.util.zip.ZipEntry: int hashCode()><ca.mcgill.sable.soot.jimple.JLeExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getInterfaces()>|<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.LinkedList$LinkedListIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.coffi.Instruction_Aload_0: void <init>()>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.UnitBox[],ca.mcgill.sable.soot.jimple.UnitBox)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)><ca.mcgill.sable.soot.grimp.GCastExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.HashSet: boolean contains(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Iaload: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$34: void handleIntCase()>).*<java.util.Vector: java.util.Enumeration elements()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.ErroneousType: void <clinit>()><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>).*<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean addAll(ca.mcgill.sable.util.Collection)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$20: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.NotDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.Timer: void start()><ca.mcgill.sable.soot.jimple.ClassHierarchy: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ret_w: void <init>()>
.*<ca.mcgill.sable.soot.RefType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Aload_3: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.GroupIntPair: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.grimp.GOrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Astore_0: void <init>()>).*<ca.mcgill.sable.util.AbstractMap$ValueCollection: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.jimple.Unit getEndUnit()><ca.mcgill.sable.soot.jimple.JInvokeStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.grimp.GCmpExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: int getSizeCount()><ca.mcgill.sable.soot.jimple.JAndExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>
.*<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>.*<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<java.util.concurrent.atomic.AtomicInteger: java.lang.String toString()>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeRef()><ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.RefType: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.Type getType()>|<java.util.Vector: void removeAllElements()>)
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.JSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ShrExpr newShrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Istore_1: void <init>()>
.*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.jimple.TypeResolver: void propagateConstrains()>).*<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)>|<ca.mcgill.sable.soot.coffi.Instruction_Dup: void <init>()><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.util.AbstractMap: ca.mcgill.sable.util.Collection values()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<java.io.ObjectOutputStream$DebugTraceInfoStack: java.lang.String toString()><java.math.BigDecimal: int hashCode()>).*<ca.mcgill.sable.soot.ArrayType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.DoubleType: void <clinit>()><ca.mcgill.sable.soot.SootClass: void setModifiers(int)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.JasminClass$27: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.coffi.Instruction_Lrem: void <init>()>).*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.SootClass: void addMethod(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>).*<ca.mcgill.sable.soot.SootField: boolean isDeclared()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toString()><ca.mcgill.sable.soot.grimp.AbstractGrimpIntLongBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.AbstractCollection: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()><java.text.DecimalFormat: void <init>(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.soot.ArrayType getBaseType()>
.*<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>.*(<ca.mcgill.sable.soot.ShortType: int hashCode()>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNullConstant(ca.mcgill.sable.soot.jimple.NullConstant)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrCannotBeDouble()>).*<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.NullType: ca.mcgill.sable.soot.NullType v()><ca.mcgill.sable.util.AbstractMap: int size()>).*<java.text.AttributedCharacterIterator$Attribute: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_Invokevirtual: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Newarray: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.FutureStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Lload: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>|<java.io.ByteArrayOutputStream: java.lang.String toString()><ca.mcgill.sable.util.Collections$UnmodIterator: void <init>(ca.mcgill.sable.util.Iterator)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticInvokeExpr newStaticInvokeExpr(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><java.net.NetworkInterface: java.lang.String toString()>).*<ca.mcgill.sable.soot.grimp.GEnterMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.coffi.TypeArray: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.CFG: int typeSize(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>).*<java.io.FileInputStream: void <init>(java.io.File)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object[] toArray()><ca.mcgill.sable.util.NoSuchElementException: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)><ca.mcgill.sable.soot.coffi.Instruction_Checkcast: void <init>()>).*<ca.mcgill.sable.soot.grimp.GEnterMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.math.BigDecimal: java.lang.String toString()><ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void copy(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.IntConstant: void <init>(int)>
.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.util.AbstractList: void <init>()><ca.mcgill.sable.soot.StoredBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.soot.CharType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JCmpgExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.NotDeclaredException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()>|<ca.mcgill.sable.soot.coffi.Instruction_Daload: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dstore_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.RefType: void <init>(java.lang.String)><ca.mcgill.sable.util.VectorSet$VectorIterator: boolean hasNext()>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.IntSet: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>
.*(<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>|<ca.mcgill.sable.soot.jimple.JasminClass$22: void handleIntCase()><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>).*<java.util.regex.Matcher: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>.*<ca.mcgill.sable.soot.jimple.JRetStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.BaseType: void <init>()>|<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>)
.*(<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString(java.lang.String,ca.mcgill.sable.soot.jimple.Value,java.lang.String)>|<ca.mcgill.sable.util.LinkedList: void removeNode(ca.mcgill.sable.util.LinkedList$Node)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<java.util.StringTokenizer: java.lang.Object nextElement()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.EqExpr newEqExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.StmtList: void <init>(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.soot.coffi.Exception_attribute: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.soot.jimple.JInvokeStmt: ca.mcgill.sable.soot.jimple.Value getInvokeExpr()><ca.mcgill.sable.soot.jimple.JasminClass: int sizeOfType(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()>|<ca.mcgill.sable.soot.jimple.FlowUniverse: int getIndexOf(java.lang.Object)><ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)><ca.mcgill.sable.soot.CharType: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.TableSwitchStmt newTableSwitchStmt(ca.mcgill.sable.soot.jimple.Value,int,int,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void copy(ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.util.ArrayList$ArrayIterator: void <init>(ca.mcgill.sable.util.ArrayList)>).*<java.net.URI: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: void <clinit>()><ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getParent()>).*<ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String)>
.*(<ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ArrayRef newArrayRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.AbstractMap: java.lang.Object put(java.lang.Object,java.lang.Object)>).*<java.text.ParsePosition: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<java.io.ObjectInputStream: void close()><ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: void offsetToPointer(ca.mcgill.sable.soot.coffi.ByteCode)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AddExpr newAddExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void clear()><ca.mcgill.sable.soot.jimple.TypeResolver: java.util.Hashtable access$0(ca.mcgill.sable.soot.jimple.TypeResolver)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newIdentityRefBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.util.HashMap$HashEntry: void <init>(ca.mcgill.sable.util.HashMap,java.lang.Object)><ca.mcgill.sable.soot.coffi.Instruction_Getfield: void <init>()>).*<ca.mcgill.sable.soot.grimp.GEqExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.Type: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.SparseLiveLocals: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>
.*(<ca.mcgill.sable.soot.jimple.DeadCodeEliminator: void eliminateDeadCode(ca.mcgill.sable.soot.jimple.JimpleBody)>|<sun.misc.FloatingDecimal: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$5: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>).*<java.util.AbstractSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalUses: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LocalDefs)>|<ca.mcgill.sable.soot.jimple.JAndExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<java.io.ObjectOutputStream$DebugTraceInfoStack: java.lang.String toString()>
.*(<ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: ca.mcgill.sable.util.List getExceptionTypes()>).*<ca.mcgill.sable.util.SplayTreeMap: int access$2(ca.mcgill.sable.util.SplayTreeMap)>
.*<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*(<ca.mcgill.sable.soot.TypeSwitch: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseCharType(ca.mcgill.sable.soot.CharType)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.coffi.Instruction_Invokevirtual: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.BasicBlock: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$20: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dload_0: void <init>()><ca.mcgill.sable.soot.jimple.JThrowStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<java.util.StringTokenizer: boolean hasMoreElements()>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String paddedLeftOf(java.lang.String,int)>|<ca.mcgill.sable.soot.jimple.JLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)><java.text.AttributedCharacterIterator$Attribute: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractMap$KeySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><ca.mcgill.sable.soot.coffi.Instruction_Fstore_1: void <init>()>).*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.StmtAddressType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)><ca.mcgill.sable.soot.coffi.CFG: void adjustExceptionTable()>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.jimple.JasminClass$6: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>).*<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object get(int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.MulExpr newMulExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.SootClass: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)>|<java.net.URL: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$34: void handleIntCase()>).*<ca.mcgill.sable.soot.coffi.BasicBlock: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)><ca.mcgill.sable.soot.jimple.AbstractNewExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>|<ca.mcgill.sable.soot.coffi.Instruction_Iand: void <init>()><java.util.Vector: boolean equals(java.lang.Object)>).*<java.util.StringTokenizer: boolean hasMoreElements()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>|<ca.mcgill.sable.soot.jimple.TypeResolver: boolean access$3()><ca.mcgill.sable.soot.jimple.FlowUniverse: void <init>(java.lang.Object[])>).*<ca.mcgill.sable.soot.jimple.JasminClass$6: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.coffi.Util: void resolveClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_3: void <init>()><ca.mcgill.sable.soot.ClassFileBody: void <init>(ca.mcgill.sable.soot.SootMethod)>).*<java.math.MathContext: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.jimple.JasminClass$36: void handleIntCase()><ca.mcgill.sable.soot.coffi.line_number_table_entry: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GGeExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>
.*(<ca.mcgill.sable.soot.jimple.GroupIntPair: int hashCode()>|<ca.mcgill.sable.soot.coffi.CFG: boolean jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JLeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.AbstractCollection: boolean addAll(ca.mcgill.sable.util.Collection)>).*<ca.mcgill.sable.util.HashMap: boolean containsKey(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)><ca.mcgill.sable.soot.FloatType: void <clinit>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Frem: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.util.Arrays$ArrayList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.ErroneousType: void <clinit>()>
.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>.*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()>.*(<ca.mcgill.sable.soot.jimple.JasminClass: void assignColorsToLocals(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.RefType: java.lang.String toString()>)
.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>)
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>.*(<ca.mcgill.sable.soot.jimple.FlowAnalysis: java.lang.Object getFlowAfterStmt(ca.mcgill.sable.soot.jimple.Stmt)>|<java.security.Timestamp: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.Type jimpleReturnTypeOfMethodRef(ca.mcgill.sable.soot.SootClassManager,ca.mcgill.sable.soot.coffi.cp_info[],int)><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>
(<ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Set keySet()>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractMap$KeyIterator: void remove()><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>).*<ca.mcgill.sable.soot.jimple.JasminClass$37: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)><java.io.PrintWriter: void println(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void setHighestBlock(ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)><java.security.Provider$Service: java.lang.String toString()>).*<ca.mcgill.sable.util.VectorSet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_longbranch: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.coffi.LineNumberTable_attribute: void <init>()>).*<ca.mcgill.sable.soot.BooleanType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toString()><ca.mcgill.sable.soot.coffi.local_variable_table_entry: void <init>()>).*<ca.mcgill.sable.soot.coffi.FutureStmt: ca.mcgill.sable.util.List getUseBoxes()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>.*(<ca.mcgill.sable.util.Collections$UnmodList: int hashCode()>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.util.List getUseBoxes()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<java.net.Proxy: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.Local: java.lang.String toBriefString()>).*<java.util.Hashtable: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Collections$UnmodListIterator: void remove()><ca.mcgill.sable.soot.jimple.JasminClass$35: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.IntType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.util.VectorList: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: int parse(byte[],int)>
.*<ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>.*(<java.io.ObjectStreamField: java.lang.String toString()>|<ca.mcgill.sable.util.IntSet: void <init>(ca.mcgill.sable.util.IntSet)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Collection)><ca.mcgill.sable.soot.jimple.JAddExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.grimp.GCmpExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Sipush: void <init>()><ca.mcgill.sable.soot.jimple.LongConstant: void <init>(long)>).*<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_0: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$21: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.jimple.JGeExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClass getSuperClass()><ca.mcgill.sable.soot.grimp.GArrayRef: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.GInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateConstrains()>|<ca.mcgill.sable.util.HashMap: void <init>(int,float)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>).*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.Timer: void start()><ca.mcgill.sable.soot.jimple.JasminClass$22: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.jimple.Local: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.util.LinkedList: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$32: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.Object getValue()><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)><ca.mcgill.sable.soot.coffi.Util: void resetEasyNames()>).*<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.coffi.Instruction_int: void <init>(byte)>).*<ca.mcgill.sable.util.AbstractList: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticInvokeExpr newStaticInvokeExpr(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTarget(int,ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.util.AbstractMap$KeySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.TypeResolver: void error(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$8: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.coffi.FutureStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.Type getReturnType()><java.util.Hashtable$Entry: java.lang.String toString()>).*<java.util.BitSet: void or(java.util.BitSet)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toString(ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.coffi.Instruction_Monitorenter: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Dneg: void <init>()>).*<java.util.AbstractList: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.DoubleType: int hashCode()><ca.mcgill.sable.util.Collections$UnmodListIterator: void set(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String toString()>|<ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()><ca.mcgill.sable.soot.SootMethod: void setSource(ca.mcgill.sable.soot.coffi.ClassFile,ca.mcgill.sable.soot.coffi.method_info)>).*<ca.mcgill.sable.util.HashMap$HashEntry: void <init>(ca.mcgill.sable.util.HashMap,java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>.*<ca.mcgill.sable.soot.StmtAddressType: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.BooleanType: boolean equals(java.lang.Object)>|<ca.mcgill.sable.util.VectorSet: ca.mcgill.sable.util.Iterator iterator()>)
.*<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>.*<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*(<ca.mcgill.sable.soot.SootField: ca.mcgill.sable.soot.SootClass getDeclaringClass()>|<ca.mcgill.sable.util.ArrayList: void add(int,java.lang.Object)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: void removeElementAt(int)><ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.UnitBox,ca.mcgill.sable.soot.jimple.UnitBox,ca.mcgill.sable.soot.jimple.UnitBox)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.SootClass: boolean implementsInterface(java.lang.String)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.Instruction_Astore_1: void <init>()>).*<ca.mcgill.sable.util.ArraySet: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_3: void <init>()><ca.mcgill.sable.soot.grimp.ObjExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractStmt: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClass getSuperClass()>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean isEcrArray()><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.util.List getUseBoxes()>).*<java.util.Hashtable: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.soot.jimple.ThisRef: ca.mcgill.sable.util.List getUseBoxes()>).*<java.util.Locale: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.AbstractList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)><ca.mcgill.sable.soot.jimple.JasminClass$19: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.coffi.Instruction_Lstore_3: void <init>()>|<ca.mcgill.sable.soot.coffi.ByteCode: void <init>()><ca.mcgill.sable.soot.jimple.JReturnVoidStmt: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction: void <init>(byte)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.GeExpr newGeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
.*<ca.mcgill.sable.soot.jimple.JInvokeStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toString()>.*(<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)>|<ca.mcgill.sable.soot.grimp.GAndExpr: java.lang.String getSymbol()>)
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>|<java.util.Vector: java.lang.Object firstElement()><ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.soot.jimple.ValueBox[])>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type[] jimpleTypesOfFieldOrMethodDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_If_icmplt: void <init>()>).*<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getIndex()>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction: void <init>(byte)><ca.mcgill.sable.soot.jimple.JNopStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Aastore: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>).*<ca.mcgill.sable.soot.coffi.TypeStack: java.lang.Object clone()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Dstore_3: void <init>()><ca.mcgill.sable.soot.jimple.Local: boolean equals(java.lang.Object)>).*<java.net.NetworkInterface: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.util.AbstractMap: int hashCode()>|<ca.mcgill.sable.soot.coffi.Instruction_Monitorexit: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Ifle: void <init>()>).*<java.util.Date: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Ladd: void <init>()><ca.mcgill.sable.util.ArraySet$ArrayIterator: void remove()>).*<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: int getArgCount()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass: void print(java.io.PrintWriter)><ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()>).*<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmple: void <init>()><java.io.ObjectStreamClass: java.lang.String toString()>).*<ca.mcgill.sable.util.SplayTreeMap: int access$0(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)><ca.mcgill.sable.soot.grimp.GLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_byteindex: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)><ca.mcgill.sable.soot.jimple.AbstractNonStaticInvokeExpr: void setBase(ca.mcgill.sable.soot.jimple.Value)>).*<java.security.AccessControlContext: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void computeArrayDepths()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.DivExpr newDivExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$28: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Utf8_Enumeration: boolean hasMoreElements()>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)><ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.ErroneousType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.ArraySparseSet: void add(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseFloatType(ca.mcgill.sable.soot.FloatType)>.*<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize()>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getUnitBoxes()>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)><ca.mcgill.sable.soot.coffi.Instruction_longbranch: int nextOffset(int)>).*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: int nextOffset(int)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>).*<ca.mcgill.sable.soot.IntType: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Arrays$ArrayList: int size()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCaughtExceptionRef(ca.mcgill.sable.soot.jimple.CaughtExceptionRef)>).*<ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$35: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.grimp.GThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.ClassFile: void parse()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_F2l: void <init>()>).*<ca.mcgill.sable.soot.ShortType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.StaticFieldRef newStaticFieldRef(ca.mcgill.sable.soot.SootField)>).*<java.io.ObjectInputStream$PeekInputStream: void close()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<java.text.ParsePosition: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JAssignStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.FlowUniverse: int getIndexOf(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractMap$KeySet: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.LongType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.BreakpointStmt newBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*(<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newImmediateBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ThrowStmt newThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>).*<ca.mcgill.sable.util.Collections$UnmodList: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.VectorSet: int size()><ca.mcgill.sable.util.ArrayList: java.lang.Object[] access$1(ca.mcgill.sable.util.ArrayList)>).*<java.util.Hashtable: boolean containsKey(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)><ca.mcgill.sable.soot.jimple.JasminClass$30: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.JIdentityStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.coffi.Util: void resetEasyNames()><java.util.Vector: java.util.Enumeration elements()>).*<ca.mcgill.sable.soot.coffi.Instruction_D2l: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<java.text.DecimalFormat: int hashCode()><ca.mcgill.sable.soot.Timer: void start()>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.grimp.GShrExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<java.util.AbstractCollection: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.RefType: int hashCode()>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.UnitBox)>|<ca.mcgill.sable.soot.coffi.Instruction_Fload_0: void <init>()><ca.mcgill.sable.soot.coffi.line_number_table_entry: void <init>()>).*<ca.mcgill.sable.util.AbstractList: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter)>|<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.grimp.GrimpBody: int getLocalCount()>).*<ca.mcgill.sable.soot.grimp.GEnterMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<java.net.InterfaceAddress: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$36: void handleIntCase()>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getMethods()>|<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString(ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.jimple.LocalCopy: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Local)>).*<ca.mcgill.sable.soot.coffi.Instruction_Putstatic: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.coffi.Long2ndHalfType: ca.mcgill.sable.soot.coffi.Long2ndHalfType v()><ca.mcgill.sable.soot.jimple.JasminClass$37: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lstore_3: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.Instruction_Aconst_null: void <init>()>).*<ca.mcgill.sable.util.AbstractMap$KeySet: int size()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.ImmediateBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$5: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: java.lang.String convert()>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.IfStmt newIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><java.io.DataInputStream: int readUnsignedByte()>).*<ca.mcgill.sable.soot.UnknownType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.jimple.Unit getEndUnit()><ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: int getPrecedence()>).*<ca.mcgill.sable.soot.coffi.Instruction_Aaload: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>.*<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>.*(<ca.mcgill.sable.util.LinkedList: void removeNode(ca.mcgill.sable.util.LinkedList$Node)>|<ca.mcgill.sable.soot.jimple.CompleteStmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList)>)
.*(<ca.mcgill.sable.soot.ByteType: void apply(ca.mcgill.sable.util.Switch)>|<java.net.NetworkInterface: int hashCode()><ca.mcgill.sable.util.SplayTreeMap: boolean containsKey(java.lang.Object)>).*<ca.mcgill.sable.soot.DoubleType: ca.mcgill.sable.soot.DoubleType v()>
.*(<ca.mcgill.sable.soot.grimp.GNeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.ByteCode: void build(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.util.LinkedList$LinkedListIterator: void remove()>).*<ca.mcgill.sable.soot.jimple.JasminClass$32: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.ByteType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.FlowUniverse: void <init>(java.lang.Object[])><ca.mcgill.sable.soot.jimple.JasminClass$25: void handleIntCase()>).*<ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.soot.jimple.Unit getTarget()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<java.net.SocketPermission: int hashCode()><ca.mcgill.sable.soot.CharType: ca.mcgill.sable.soot.CharType v()>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void setTarget(int,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.jimple.JMulExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>).*<java.util.AbstractSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseNullType(ca.mcgill.sable.soot.NullType)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.coffi.Instruction_Checkcast: void <init>()>).*<ca.mcgill.sable.util.NoSuchElementException: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)><ca.mcgill.sable.soot.ClassFileBody: void <init>(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.soot.grimp.GCmpExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*<ca.mcgill.sable.soot.jimple.ConstantAndCopyPropagator: void propagateConstantsAndCopies(ca.mcgill.sable.soot.jimple.StmtBody)>.*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: ca.mcgill.sable.util.List getDefBoxes()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewExpr newNewExpr(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>.*<ca.mcgill.sable.soot.VoidType: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.RefType: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String getDeclaration()>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.jimple.Local getLocalForStackOp(ca.mcgill.sable.soot.jimple.JimpleBody,ca.mcgill.sable.soot.coffi.TypeStack,int)><ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)>|<ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String parseDesc(java.lang.String,java.lang.String)><ca.mcgill.sable.soot.ByteType: int hashCode()>).*<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>.*(<ca.mcgill.sable.util.NoCast: java.lang.Object cast(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.Transformations: void removeUnusedLocals(ca.mcgill.sable.soot.jimple.StmtBody)>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Istore_1: void <init>()><ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()>).*<java.util.Hashtable: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: java.lang.String toString()>|<ca.mcgill.sable.util.IntSet: void and(ca.mcgill.sable.util.IntSet)><ca.mcgill.sable.soot.jimple.LocalCopy: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.UnsupportedOperationException: void <init>()>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String parseMethodDesc_params(java.lang.String)>|<ca.mcgill.sable.soot.coffi.Instruction_Aconst_null: void <init>()><java.io.DataInputStream: int readUnsignedByte()>).*<java.net.InetAddress: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.ConditionExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean add(java.lang.Object)>).*<java.math.MathContext: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Utf8_Enumeration: java.lang.Object nextElement()><java.util.Vector: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getTarget(int)>
.*(<ca.mcgill.sable.soot.jimple.JGotoStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Hashtable: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$4: void caseStmtAddressType(ca.mcgill.sable.soot.StmtAddressType)>).*<ca.mcgill.sable.soot.grimp.GCmpgExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)><ca.mcgill.sable.soot.UnknownType: java.lang.String toString()>).*<ca.mcgill.sable.soot.DoubleType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.soot.jimple.Value getReturnValue()><ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object,int)>).*<ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.SootClass: void setName(java.lang.String)><ca.mcgill.sable.soot.coffi.CFG: void buildJsrRetPairs()>).*<java.io.FileInputStream: void <init>(java.io.File)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toBriefString()><ca.mcgill.sable.util.AbstractMap$KeyIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>).*<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void copy(ca.mcgill.sable.soot.jimple.FlowSet)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<java.net.URI: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Dcmpg: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Land: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.text.MessageFormat: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass$2: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.util.ArraySet$ArrayIterator: void remove()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>).*<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void defaultCase(ca.mcgill.sable.soot.Type)><java.text.MessageFormat: java.lang.Object clone()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.coffi.Instruction_Iconst_2: void <init>()>).*<ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String toString()>
(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InstanceFieldRef newInstanceFieldRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$21: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.JasminClass,ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.CastExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String)><java.util.Locale: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.Type jimpleTypeOfAtype(int)>).*<java.security.Timestamp: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.grimp.ExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.Type: void apply(ca.mcgill.sable.util.Switch)>).*<java.math.BigDecimal: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void remove()>|<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.jimple.Local getLocalForStackOp(ca.mcgill.sable.soot.jimple.JimpleBody,ca.mcgill.sable.soot.coffi.TypeStack,int)><ca.mcgill.sable.soot.jimple.SimpleLocalUses: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LocalDefs)>).*<ca.mcgill.sable.soot.SootField: void setType(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newInvokeExprBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])>).*<ca.mcgill.sable.soot.coffi.Instruction_Ladd: void <init>()>
.*(<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>|<ca.mcgill.sable.soot.jimple.JCmpExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Lload_1: void <init>()>).*<java.net.Proxy: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.jimple.AbstractNewExpr: void apply(ca.mcgill.sable.util.Switch)><java.text.ParsePosition: boolean equals(java.lang.Object)>).*<java.util.jar.Manifest$FastInputStream: void close()>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.util.SplayTreeMap$Node: void setLeft(ca.mcgill.sable.util.SplayTreeMap$Node)>).*<java.util.Hashtable: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)><java.util.Date: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JRetStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.coffi.TypeStack: int topIndex()>).*<java.util.Hashtable: void <clinit>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>.*<ca.mcgill.sable.soot.SootField: java.lang.String getSignature()>.*(<java.io.ByteArrayInputStream: void <init>(byte[])>|<ca.mcgill.sable.soot.coffi.Instruction_Ixor: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.TableSwitchStmt newTableSwitchStmt(ca.mcgill.sable.soot.jimple.Value,int,int,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.StaticFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ArrayType: ca.mcgill.sable.soot.ArrayType v(ca.mcgill.sable.soot.BaseType,int)><ca.mcgill.sable.soot.coffi.Instruction_Ifnull: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: java.lang.String toString()>
(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.jimple.StmtBox: void <init>(ca.mcgill.sable.soot.jimple.Stmt)>).*<ca.mcgill.sable.soot.coffi.Instruction_I2d: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$24: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void handleIntCase()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.BooleanType: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$32: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: void <init>(ca.mcgill.sable.util.LinkedList,int)>
.*(<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.SubExpr newSubExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$36: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.coffi.Instruction: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.coffi.CONSTANT_Fieldref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>).*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.JasminClass$13: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$34: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.Main: java.lang.String paddedLeftOf(java.lang.String,int)><java.util.Vector: boolean contains(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GInterfaceInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: void <init>()>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>|<java.nio.ByteOrder: java.lang.String toString()><ca.mcgill.sable.soot.IntType: java.lang.String toString()>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JCmpExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JInvokeStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.coffi.Instruction_L2d: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>|<ca.mcgill.sable.util.LinkedList$Node: void <init>(ca.mcgill.sable.util.LinkedList,java.lang.Object)><ca.mcgill.sable.soot.TypeSwitch: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.JArrayRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.Local: java.lang.String toString()><java.util.HashMap$Entry: int hashCode()>).*<ca.mcgill.sable.soot.jimple.JNewExpr: void <init>(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.BuildBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JAssignStmt: void setLeftOp(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GrimpBody$2: void <init>(ca.mcgill.sable.util.HashMap)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_2: void <init>()><ca.mcgill.sable.soot.jimple.StmtValueBoxPair: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.Collections$UnmodListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.jimple.Constant: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$27: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.JShrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.SootMethod: int getModifiers()>).*<ca.mcgill.sable.soot.coffi.Instruction_Breakpoint: void <init>()>
.*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.CmpgExpr newCmpgExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>)
.*(<ca.mcgill.sable.soot.jimple.SimpleLiveLocals: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.util.VectorList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Istore: void <init>()><ca.mcgill.sable.soot.jimple.LocalCopy: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Local)>).*<ca.mcgill.sable.util.NoCast: java.lang.Object cast(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.coffi.Instruction_Imul: void <init>()><ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ThrowStmt newThrowStmt(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JAndExpr: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.JCmplExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseReturnVoidStmt(ca.mcgill.sable.soot.jimple.ReturnVoidStmt)>).*<java.security.Timestamp: int hashCode()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>.*(<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object get(int)>|<ca.mcgill.sable.soot.coffi.Instruction_Athrow: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)><ca.mcgill.sable.soot.jimple.JasminClass$22: void handleIntCase()>).*<ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.SootField getField()>
.*(<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toString()>|<ca.mcgill.sable.soot.baf.Baf: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)><ca.mcgill.sable.soot.jimple.Local: java.lang.Object clone()>).*<java.math.MathContext: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.Modifier: boolean isFinal(int)><java.util.jar.Attributes: int hashCode()>).*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.soot.jimple.Value getSize(int)>
.*(<ca.mcgill.sable.soot.jimple.DeadCodeEliminator: void eliminateDeadCode(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.SubExpr newSubExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><java.io.DataInputStream: int readUnsignedByte()>).*<ca.mcgill.sable.soot.IntType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitBooleanBranch(java.lang.String)><ca.mcgill.sable.soot.IntType: void <clinit>()>).*<ca.mcgill.sable.soot.NullType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void <init>(ca.mcgill.sable.soot.jimple.FlowUniverse,int[])>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>
.*<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseFloatType(ca.mcgill.sable.soot.FloatType)>.*(<ca.mcgill.sable.soot.grimp.GNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.jimple.JasminClass: void okayEmit(java.lang.String)>)
.*(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.util.HashMap: boolean containsKey(java.lang.Object)><java.util.Hashtable: void <init>(int,float)>).*<ca.mcgill.sable.soot.grimp.GSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Iconst_3: void <init>()><ca.mcgill.sable.soot.grimp.GrimpBody$2: void <init>(ca.mcgill.sable.util.HashMap)>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: int getTargetCount()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.Local: java.lang.String getName()><ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.grimp.GInstanceOfExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.util.HashMap$HashEntry: int hashCode()>|<ca.mcgill.sable.soot.SootClassManager: ca.mcgill.sable.soot.SootClass getClass(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<java.net.SocketPermission: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JasminClass$6: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.IfStmt newIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>
.*(<ca.mcgill.sable.soot.StoredBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.SootClass: void resolve()><ca.mcgill.sable.soot.SootClass: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.BasicBlock: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.baf.BafBody: void <init>(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.util.Collections$UnmodIterator: void remove()><java.util.jar.Attributes: java.lang.Object clone()>).*<ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.soot.jimple.IdentityRefBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$8: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: void difference(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>.*<ca.mcgill.sable.soot.jimple.JNopStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>|<ca.mcgill.sable.soot.coffi.FutureStmt: void <init>()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>|<ca.mcgill.sable.soot.SootMethod: java.lang.String getDeclaration()><ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: int size()>).*<ca.mcgill.sable.util.Arrays$ArrayList: java.lang.Object set(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)><ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.jimple.LocalBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.Value newExpr(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JSubExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.XorExpr newXorExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.net.Proxy: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_intindex: int parse(byte[],int)>).*<ca.mcgill.sable.soot.NullType: ca.mcgill.sable.soot.NullType v()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>.*<ca.mcgill.sable.soot.jimple.JIfStmt: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>|<ca.mcgill.sable.soot.coffi.Instruction_Dstore: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.JInvokeStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$11: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getTargets()><ca.mcgill.sable.soot.coffi.FutureStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iconst_2: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>.*(<ca.mcgill.sable.soot.jimple.ParameterRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.IfStmt newIfStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void <init>()>).*<ca.mcgill.sable.util.IntSet: void clear(int)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<java.util.jar.Attributes$Name: boolean equals(java.lang.Object)><java.security.BasicPermission: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JNeExpr: java.lang.String getSymbol()>
.*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseCharType(ca.mcgill.sable.soot.CharType)>.*(<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toString(ca.mcgill.sable.soot.jimple.Value,java.lang.String,java.lang.String)>|<ca.mcgill.sable.util.Arrays$ArrayList: int size()>)
.*(<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseCharType(ca.mcgill.sable.soot.CharType)><java.util.HashMap: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Arrays: ca.mcgill.sable.util.List toList(java.lang.Object[])><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.BackwardFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<java.util.Hashtable: int size()><ca.mcgill.sable.util.LinkedList$LinkedListIterator: int nextIndex()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iadd: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InvokeStmt newInvokeStmt(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void print_debug(java.io.PrintWriter)>|<ca.mcgill.sable.soot.coffi.Instruction_Lshr: void <init>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.Trap newTrap(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getValue()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseByteType(ca.mcgill.sable.soot.ByteType)><java.net.NetworkInterface: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>.*(<ca.mcgill.sable.util.ArrayList: int access$0(ca.mcgill.sable.util.ArrayList)>|<java.text.AttributedCharacterIterator$Attribute: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.SootClass: void addField(ca.mcgill.sable.soot.SootField)>|<ca.mcgill.sable.soot.SootMethod: void setReturnType(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.LinkedList$Node: void setNext(ca.mcgill.sable.util.LinkedList$Node)>).*<ca.mcgill.sable.soot.BooleanType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()>|<ca.mcgill.sable.soot.jimple.ClassHierarchy: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Goto: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.coffi.FutureStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: ca.mcgill.sable.util.List getUnitBoxes()>|<ca.mcgill.sable.soot.jimple.ParameterRef: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>).*<java.util.Vector: boolean contains(java.lang.Object)>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.Modifier: boolean isNative(int)><ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.jimple.LongConstant: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: void <init>()><ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Fcmpl: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()>|<ca.mcgill.sable.soot.coffi.Instruction_Dstore_3: void <init>()><ca.mcgill.sable.soot.grimp.GUshrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.grimp.GOrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.ByteType: ca.mcgill.sable.soot.ByteType v()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Monitorexit: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.AssignStmt newAssignStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><java.text.NumberFormat: void <clinit>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Sastore: void <init>()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.soot.SootClass: void addInterface(ca.mcgill.sable.soot.SootClass)>.*(<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.coffi.Instruction_Getstatic: void <init>()>)
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy)><ca.mcgill.sable.soot.coffi.CFG: void JsrEliminate()>).*<java.net.NetworkInterface: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.jimple.StmtGraph: int size()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)><ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type jimpleReturnTypeOfMethodDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iconst_5: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.coffi.Instruction_Faload: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.JBreakpointStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>|<ca.mcgill.sable.soot.jimple.LocalSplitter: void splitLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>)
.*(<ca.mcgill.sable.soot.CharType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()><java.util.Locale: java.lang.Object clone()>).*<sun.misc.FloatingDecimal: void <init>(float)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>.*<ca.mcgill.sable.soot.SootClass: void addField(ca.mcgill.sable.soot.SootField)>.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.coffi.cp_info: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void eliminateBackPointersTo(ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lconst_1: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.FloatConstant: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JRetStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.Grimp$1: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JLeExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.BooleanType: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>
.*(<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: int size()>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.util.HashMap: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.grimp.GLtExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.coffi.local_variable_table_entry: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_intindex: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.grimp.GAddExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)><ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>
.*(<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ClassFileBody: ca.mcgill.sable.soot.SootMethod getMethod()><sun.security.util.SecurityConstants: void <clinit>()>).*<java.util.Hashtable: java.lang.Object get(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.soot.SootClass: void setModifiers(int)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.jimple.ThisRef: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,int,int,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.jimple.JasminClass$16: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dconst_1: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)><ca.mcgill.sable.util.ArrayList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.TypeResolver: void access$2(java.lang.String)>
.*(<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>|<java.text.NumberFormat: java.lang.String format(double)><ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>).*<java.security.Timestamp: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.LinkedList: java.lang.Object removeFirst()><ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<ca.mcgill.sable.util.Collections$UnmodList: void <init>(ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Lshr: void <init>()><ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>).*<ca.mcgill.sable.soot.grimp.Grimp: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseFloatConstant(ca.mcgill.sable.soot.jimple.FloatConstant)><ca.mcgill.sable.soot.jimple.TypeResolver: void mergeBaseTypeArrays()>).*<ca.mcgill.sable.soot.ShortType: void <clinit>()>
.*(<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.jimple.LongConstant: java.lang.String toString()><ca.mcgill.sable.util.IntSet: void grow()>).*<ca.mcgill.sable.util.HashSet: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.coffi.CFG: void <init>(ca.mcgill.sable.soot.coffi.method_info)><ca.mcgill.sable.soot.jimple.JasminClass$36: void handleIntCase()>).*<ca.mcgill.sable.soot.RefType: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.jimple.StmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList,boolean)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.IntType: int hashCode()><ca.mcgill.sable.util.SplayTreeMap$EntryCollection: int size()>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void remove()><ca.mcgill.sable.soot.jimple.JasminClass$37: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>.*<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toString()>.*(<ca.mcgill.sable.soot.coffi.Instruction_Lshl: void <init>()>|<ca.mcgill.sable.util.AbstractList$AbstractListIterator: boolean hasNext()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.ByteType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$34: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.LinkedList computeOrder(boolean)>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.JasminClass$22: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<java.security.AllPermission: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack merge(ca.mcgill.sable.soot.coffi.TypeStack)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_1: void <init>()>
.*(<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.grimp.ObjExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.coffi.Instruction_Freturn: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$5: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.JIfStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.Type getReturnType()>).*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ThrowStmt newThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<java.io.ObjectStreamClass: java.lang.String toString()><java.math.BigDecimal: int hashCode()>).*<ca.mcgill.sable.soot.jimple.JThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.SootClass: void setSuperClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.soot.jimple.Value getOp()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Tableswitch: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.util.LinkedList: void removeNode(ca.mcgill.sable.util.LinkedList$Node)><ca.mcgill.sable.soot.jimple.Jimple: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Freturn: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.BriefStmtGraph: void <init>(ca.mcgill.sable.soot.jimple.StmtList)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>).*<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void <init>(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)><ca.mcgill.sable.soot.grimp.GGtExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.coffi.Instruction_L2f: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JasminClass$1: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.NullConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.util.LinkedList$Node: java.lang.Object getElement()>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseTableSwitchStmt(ca.mcgill.sable.soot.jimple.TableSwitchStmt)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AssignStmt newAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>
.*(<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.TypeSwitch: void caseNullType(ca.mcgill.sable.soot.NullType)><ca.mcgill.sable.soot.coffi.CONSTANT_Double_info: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveComplexRelations()>|<ca.mcgill.sable.soot.jimple.FlowUniverse: java.lang.Object getObjectOf(int)><ca.mcgill.sable.soot.coffi.Instruction_Dload_0: void <init>()>).*<ca.mcgill.sable.soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>
.*(<java.net.SocketPermission: int hashCode()>|<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>).*<java.net.InterfaceAddress: int hashCode()>
.*<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>.*(<ca.mcgill.sable.soot.grimp.GAssignStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JEqExpr: java.lang.String getSymbol()>)
.*(<ca.mcgill.sable.soot.jimple.DeadCodeEliminator: void eliminateDeadCode(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$16: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>).*<ca.mcgill.sable.soot.grimp.GLtExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: java.lang.String toBriefString()>.*(<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.RemExpr newRemExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<java.io.DataInputStream: java.lang.String readUTF()><ca.mcgill.sable.soot.jimple.FlowUniverse: int getIndexOf(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.TypeResolver: void computeArrayDepths()>
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArrayList: ca.mcgill.sable.util.Iterator iterator()><ca.mcgill.sable.soot.coffi.Instruction_Frem: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getKey()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<sun.util.calendar.CalendarDate: boolean equals(java.lang.Object)><ca.mcgill.sable.util.AbstractCollection: void toArray(java.lang.Object[])>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.FloatType: java.lang.String toString()><ca.mcgill.sable.util.AbstractList$AbstractListIterator: void <init>(ca.mcgill.sable.util.AbstractList,int)>).*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<java.util.Vector: int hashCode()>)
.*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GotoStmt newGotoStmt(ca.mcgill.sable.soot.jimple.Unit)>.*(<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getDefBoxes()>|<java.net.SocketPermission: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean readConstantPool(java.io.DataInputStream)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>).*<ca.mcgill.sable.soot.jimple.JNopStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Istore_1: void <init>()><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void copy(ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)><ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.Type: ca.mcgill.sable.soot.Type merge(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.SootClassManager)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.util.ArraySet: int size()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$6: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)><ca.mcgill.sable.soot.jimple.JasminClass$13: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>
.*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>.*<ca.mcgill.sable.soot.jimple.JIdentityStmt: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.SootClass: java.lang.String toString()>|<ca.mcgill.sable.soot.TypeSwitch: void setResult(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.AbstractStmt$AllMapTo: void <init>(ca.mcgill.sable.soot.jimple.AbstractStmt,java.lang.Object)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ShrExpr newShrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.grimp.GTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.IdentityStmt newIdentityStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.SootField getField()>).*<ca.mcgill.sable.soot.coffi.TypeStack: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.AbstractDefinitionStmt: void <init>()><ca.mcgill.sable.soot.jimple.ForwardFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>).*<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.util.AbstractSequentialList: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Lneg: void <init>()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newConditionExprBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)><ca.mcgill.sable.soot.jimple.JasminClass$27: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.jimple.JShlExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GLeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.CharType: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<java.net.URL: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.JIfStmt: java.lang.String toString()>.*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()>.*(<ca.mcgill.sable.soot.coffi.Instruction_Dload_1: void <init>()>|<ca.mcgill.sable.soot.SootClass: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.Modifier: boolean isAbstract(int)><ca.mcgill.sable.soot.coffi.Instruction_Fconst_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>.*<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<java.util.Enumeration: java.lang.Object nextElement()>|<ca.mcgill.sable.soot.ByteType: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.GroupIntPair: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String)>).*<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.util.AbstractMap$KeyIterator: void <init>(ca.mcgill.sable.util.AbstractMap)><ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.jimple.AbstractValueBox: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.SootMethod: java.lang.String getDeclaration()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: boolean hasNext()>
.*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*<ca.mcgill.sable.soot.jimple.JThrowStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Dup2_x2: void <init>()>|<java.text.AttributedCharacterIterator$Attribute: int hashCode()>)
.*(<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<java.util.NoSuchElementException: void <init>(java.lang.String)><java.net.NetworkInterface: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lstore_1: void <init>()>
.*(<ca.mcgill.sable.util.AbstractMap: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.Local: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.Collections$UnmodList: int size()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void add(java.lang.Object)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.SubExpr newSubExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_If_icmpge: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Jsr: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.coffi.Instruction_Faload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: int getArgCount()>
.*(<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>|<ca.mcgill.sable.soot.coffi.Instruction_Swap: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Fastore: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.StaticInvokeExpr newStaticInvokeExpr(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.JasminClass$10: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.util.VectorList: int size()>
.*(<ca.mcgill.sable.soot.jimple.JLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StmtBox: ca.mcgill.sable.soot.jimple.Unit getUnit()><ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.TypeSwitch: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.ParameterRef: java.lang.String toString()>).*<ca.mcgill.sable.soot.TypeSwitch: void setResult(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>.*(<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void remove()>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InstanceFieldRef newInstanceFieldRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.util.ArrayList: void doubleCapacity()><ca.mcgill.sable.soot.jimple.LongConstant: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>|<ca.mcgill.sable.soot.coffi.ClassFile: void parse()><ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getValue()>).*<java.util.jar.Attributes: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Goto_w: void <init>()><ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.ArraySet: void doubleCapacity()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.coffi.Instruction_Saload: void <init>()><ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object set(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean readConstantPool(java.io.DataInputStream)>|<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.soot.jimple.Value getReturnValue()><ca.mcgill.sable.soot.jimple.ClassHierarchy: java.util.Vector access$0(ca.mcgill.sable.soot.jimple.ClassHierarchy)>).*<ca.mcgill.sable.soot.SootMethod: java.lang.String getName()>
.*(<ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.JasminClass$15: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.NoSuchElementException: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractNewExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddChild(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.util.ArraySet: void removeElementAt(int)><ca.mcgill.sable.soot.coffi.Instruction_Goto_w: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.coffi.CFG: void arrangeclonedBBinorder()><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object,int)><ca.mcgill.sable.util.AbstractCollection: boolean add(java.lang.Object)>).*<java.util.Hashtable: int size()>
.*(<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)><ca.mcgill.sable.soot.jimple.JasminClass$27: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<ca.mcgill.sable.soot.jimple.LocalCopy: boolean equals(java.lang.Object)><ca.mcgill.sable.util.AbstractCollection: java.lang.Object[] toArray()>).*<ca.mcgill.sable.soot.coffi.Instruction_Istore_2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.TypeSwitch: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.JasminClass$24: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.util.AbstractCollection: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)><java.util.Hashtable: java.lang.Object clone()>).*<ca.mcgill.sable.util.LinkedList$LinkedListIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.CFG: void prepareForGC()><ca.mcgill.sable.soot.jimple.JReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String getName()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<java.text.DecimalFormat: void <init>(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass$3: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.AlreadyThrowsException: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.AlreadyThrowsException: void <init>(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String,int)>).*<ca.mcgill.sable.soot.IntType: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JasminClass$12: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.util.HashMap: boolean isEmpty()>).*<ca.mcgill.sable.soot.jimple.LocalBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateConstrains()>|<ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getHeadJStmt()><ca.mcgill.sable.util.LinkedList$Node: void setPrevious(ca.mcgill.sable.util.LinkedList$Node)>).*<java.text.AttributedCharacterIterator$Attribute: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JTrap: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.soot.jimple.Value getOp()>).*<java.util.Date: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.SootClass: void resolveIfNecessary()>|<ca.mcgill.sable.soot.jimple.JasminClass: void emitValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.LinkedList: void addLast(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractCollection: java.lang.String toString()><ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JDivExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dstore: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecrUnion(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)><ca.mcgill.sable.util.SplayTreeMap: int access$0(ca.mcgill.sable.util.SplayTreeMap)>).*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseRefType(ca.mcgill.sable.soot.RefType)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$11: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.util.ArraySet: boolean add(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void defaultCase(ca.mcgill.sable.soot.Type)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseRemExpr(ca.mcgill.sable.soot.jimple.RemExpr)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddChild(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Dstore_1: void <init>()>|<ca.mcgill.sable.soot.FloatType: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.coffi.Instruction_Int2char: void <init>()><java.io.ByteArrayInputStream: void <init>(byte[])>).*<java.net.Proxy: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.JasminClass: int argCountOf(ca.mcgill.sable.soot.SootMethod)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.EqExpr newEqExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.util.SplayTreeMap$EntryIterator: boolean hasNext()>).*<ca.mcgill.sable.util.ArrayList$ArrayIterator: void <init>(ca.mcgill.sable.util.ArrayList)>
.*(<ca.mcgill.sable.soot.jimple.JOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.LinkedList$Node: void setPrevious(ca.mcgill.sable.util.LinkedList$Node)><ca.mcgill.sable.soot.coffi.ClassFile: java.lang.String toString()>).*<ca.mcgill.sable.soot.CharType: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.coffi.CFG: void fixupJsrRets()><ca.mcgill.sable.soot.jimple.JasminClass: void okayEmit(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.coffi.ByteCode: void <init>()><ca.mcgill.sable.soot.NullType: int hashCode()>).*<ca.mcgill.sable.soot.coffi.Instruction_If_icmplt: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_Jsr: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$32: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.soot.jimple.Value getOp()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver: boolean access$3()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void removeEcrIndirectRelations()>).*<ca.mcgill.sable.soot.jimple.JXorExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)>|<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseCharType(ca.mcgill.sable.soot.CharType)><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.jimple.LocalCopy: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<sun.misc.FloatingDecimal: void <init>(float)><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>).*<java.util.AbstractSet: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>).*<ca.mcgill.sable.soot.TypeSwitch: java.lang.Object getResult()>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.jimple.BackwardFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>).*<java.net.URL: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootField)><ca.mcgill.sable.util.SplayTreeMap: int size()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Vector: void insertElementAt(java.lang.Object,int)><ca.mcgill.sable.soot.coffi.Instruction_If_acmpeq: void <init>()>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.ArrayPackedSet: ca.mcgill.sable.util.List toList()><ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: java.lang.String getLocalVariableName(ca.mcgill.sable.soot.coffi.cp_info[],int,int)>).*<java.math.BigInteger: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.jimple.JasminClass$25: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.CharType: void <clinit>()>
.*(<ca.mcgill.sable.soot.SootClass: void setModifiers(int)>|<ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.NextNextStmtRef: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.LocalStmtPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void emitIntToTypeCast()>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int nextIndex()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GSubExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.grimp.GStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void modifyStackHeight(int)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseIntConstant(ca.mcgill.sable.soot.jimple.IntConstant)><ca.mcgill.sable.soot.jimple.JasminClass$23: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.coffi.Instruction_Lconst_1: void <init>()><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getTarget(int)>).*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.coffi.CFG: void jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int)>|<ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()><ca.mcgill.sable.soot.CharType: int hashCode()>).*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>.*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>.*(<ca.mcgill.sable.soot.ShortType: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.JGotoStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)>)
.*<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseLongType(ca.mcgill.sable.soot.LongType)>.*<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStringConstant(ca.mcgill.sable.soot.jimple.StringConstant)>|<ca.mcgill.sable.util.VectorSet: ca.mcgill.sable.util.Iterator iterator()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)><ca.mcgill.sable.util.HashMap$HashEntry: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>.*<ca.mcgill.sable.util.ArraySet: boolean add(java.lang.Object)>.*(<java.util.jar.Attributes: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>)
.*<ca.mcgill.sable.util.AbstractCollection: boolean remove(java.lang.Object)>.*<ca.mcgill.sable.util.AbstractList: boolean equals(java.lang.Object)>.*(<ca.mcgill.sable.util.AbstractList: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.Type: ca.mcgill.sable.soot.Type toMachineType(ca.mcgill.sable.soot.Type)>)
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.SpecialInvokeExpr newSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>|<ca.mcgill.sable.soot.coffi.Instruction_intvar: void <init>(byte)><ca.mcgill.sable.soot.Modifier: boolean isAbstract(int)>).*<ca.mcgill.sable.util.VectorList: int size()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Vector: void <init>(int,int)><ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: int getTargetCount()>).*<ca.mcgill.sable.soot.jimple.Local: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>|<java.security.PrivilegedActionException: void <init>(java.lang.Exception)><ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String)>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><java.text.DecimalFormat: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_Fstore_2: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)><ca.mcgill.sable.soot.grimp.AbstractGrimpIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void <init>(int,ca.mcgill.sable.soot.jimple.JasminClass,ca.mcgill.sable.soot.jimple.Local)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.RemExpr newRemExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$10: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ThisRef newThisRef(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ValueBox newLocalBox(ca.mcgill.sable.soot.jimple.Value)>)
.*<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>.*<ca.mcgill.sable.soot.grimp.GRemExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$23: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>|<java.io.ObjectInputStream: void close()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Set keySet()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.jimple.JIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Dconst_1: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractStmt$AllMapTo: java.lang.Object get(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>.*<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.util.AbstractList: java.lang.Object remove(int)>|<ca.mcgill.sable.soot.jimple.LocalBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddParent(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.coffi.Instruction_Int2char: void <init>()><ca.mcgill.sable.util.IntSet: void <init>(ca.mcgill.sable.util.IntSet)>).*<ca.mcgill.sable.soot.ArrayType: int hashCode()>
.*<ca.mcgill.sable.soot.coffi.CFG: void jimplify(ca.mcgill.sable.soot.coffi.cp_info[],int)>.*<ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction disassemble_bytecode(byte[],int)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Lload_0: void <init>()>|<ca.mcgill.sable.soot.jimple.JCmplExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)>|<ca.mcgill.sable.soot.grimp.GIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void <init>(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.BooleanType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.ArrayList: java.lang.Object set(int,java.lang.Object)><ca.mcgill.sable.soot.coffi.Double2ndHalfType: void <init>()>).*<ca.mcgill.sable.soot.grimp.GXorExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.coffi.Instruction_bytevar: int parse(byte[],int)><ca.mcgill.sable.soot.jimple.JasminClass$10: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode typeNode(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>
.*(<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toString()><ca.mcgill.sable.util.SplayTreeMap: void splay(ca.mcgill.sable.util.SplayTreeMap$Node)>).*<java.util.Vector: java.util.Enumeration elements()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.CharType: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.AbstractStmt: java.lang.String toString(ca.mcgill.sable.util.Map,java.lang.String)>.*<ca.mcgill.sable.util.HashSet: ca.mcgill.sable.util.Iterator iterator()>.*(<java.util.Hashtable: java.util.Enumeration keys()>|<ca.mcgill.sable.soot.CharType: boolean equals(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)><ca.mcgill.sable.util.AbstractSet: int hashCode()>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void <init>(ca.mcgill.sable.util.AbstractList,int)>
.*(<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)><ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClassManager getManager()>).*<ca.mcgill.sable.soot.coffi.Instruction_If_icmpge: void <init>()>
.*<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>.*<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.coffi.Instruction_Dcmpg: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.JUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmpne: void <init>()><ca.mcgill.sable.soot.jimple.LocalCopy: int hashCode()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)>|<ca.mcgill.sable.util.LinkedList$Node: void setPrevious(ca.mcgill.sable.util.LinkedList$Node)><ca.mcgill.sable.soot.coffi.ClassFile: boolean readFields(java.io.DataInputStream)>).*<ca.mcgill.sable.util.IntSet: int[] elements()>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void set(java.lang.Object)><ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.Type byteCodeTypeOf(ca.mcgill.sable.soot.Type)>).*<java.util.jar.Attributes$Name: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.ByteType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.OrExpr newOrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.IntSet: void set(int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.CFG: void fixupTargets()>).*<ca.mcgill.sable.soot.coffi.Instruction_int: void <init>(byte)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseXorExpr(ca.mcgill.sable.soot.jimple.XorExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)><java.util.Vector: void removeAllElements()>).*<ca.mcgill.sable.soot.jimple.JasminClass$5: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.util.AbstractSet: int hashCode()><ca.mcgill.sable.soot.coffi.Instruction_int: void <init>(byte)>).*<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InstanceFieldRef newInstanceFieldRef(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootField)><ca.mcgill.sable.soot.jimple.JasminClass$26: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>
.*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseByteType(ca.mcgill.sable.soot.ByteType)>.*(<java.util.Vector: int size()>|<java.util.Hashtable: boolean containsKey(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: void <clinit>()><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>|<ca.mcgill.sable.util.ArrayList: java.lang.Object get(int)><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.RefType)>.*(<ca.mcgill.sable.soot.jimple.ArrayPackedSet: void complement(ca.mcgill.sable.soot.jimple.FlowSet)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>)
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractIntLongBinopExpr: void <init>()><ca.mcgill.sable.soot.jimple.AbstractCastExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.ConcurrentModificationException: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>|<ca.mcgill.sable.soot.NotDeclaredException: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Fcmpg: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Frem: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseRefType(ca.mcgill.sable.soot.RefType)><java.util.Vector: void removeElementAt(int)>).*<ca.mcgill.sable.soot.coffi.Instruction_Aastore: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>.*<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseArrayRef(ca.mcgill.sable.soot.jimple.ArrayRef)>.*(<ca.mcgill.sable.util.SplayTreeMap$Node: void removeChild(ca.mcgill.sable.util.SplayTreeMap$Node)>|<ca.mcgill.sable.soot.jimple.JBreakpointStmt: void <init>()>)
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.LinkedList: void access$0(ca.mcgill.sable.util.LinkedList,ca.mcgill.sable.util.LinkedList$Node)><ca.mcgill.sable.soot.jimple.JNeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<java.io.FilterInputStream: void close()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.NoSuchMethodException: void <init>(java.lang.String)><ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction_Fstore_2: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LookupSwitchStmt newLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)><ca.mcgill.sable.soot.jimple.ArraySparseSet: void add(java.lang.Object)>).*<java.security.BasicPermission: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toBriefString()>.*(<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<ca.mcgill.sable.soot.jimple.JArrayRef: ca.mcgill.sable.soot.jimple.Value getBase()>)
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Collections$UnmodListIterator: void add(java.lang.Object)><ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.util.AbstractList: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.FloatType: int hashCode()><java.util.AbstractMap: java.lang.Object clone()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$3: void defaultCase(ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.coffi.cp_info: long ints2long(long,long)>)
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>|<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.FastColorer$InterferenceGraph: void setInterference(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Local)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void <init>(ca.mcgill.sable.util.TypedLinkedList,ca.mcgill.sable.util.ListIterator)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)><ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>).*<ca.mcgill.sable.soot.coffi.Instruction_Saload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.local_variable_table_entry: void <init>()><java.io.DataInputStream: int readInt()>).*<ca.mcgill.sable.soot.coffi.Instruction_Lshl: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: ca.mcgill.sable.soot.Type toInt(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.JasminClass: int sizeOfType(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>).*<java.net.URL: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.util.TypedSplayTreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getDefBoxes()>).*<ca.mcgill.sable.soot.SootMethod: void <init>(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type,int)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>.*<ca.mcgill.sable.soot.LongType: void apply(ca.mcgill.sable.util.Switch)>.*(<java.io.ByteArrayOutputStream: java.lang.String toString()>|<ca.mcgill.sable.util.AbstractList$AbstractListIterator: boolean hasNext()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()>|<ca.mcgill.sable.util.ArraySet: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.grimp.GrimpBody: int getLocalCount()>).*<ca.mcgill.sable.util.SplayTreeMap: int access$2(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<java.net.URL: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Ineg: void <init>()>).*<ca.mcgill.sable.soot.TypeSwitch: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseParameterRef(ca.mcgill.sable.soot.jimple.ParameterRef)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.soot.coffi.Instruction_Dup2: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Goto_w: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.util.SplayTreeMap: int access$0(ca.mcgill.sable.util.SplayTreeMap)>).*<ca.mcgill.sable.soot.jimple.InvokeExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.util.Iterator pseudoTopologicalOrderIterator()>|<ca.mcgill.sable.util.AbstractCollection: boolean isEmpty()><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy)>).*<java.text.AttributedCharacterIterator$Attribute: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void <init>(ca.mcgill.sable.soot.SootClass,ca.mcgill.sable.soot.BodyExpr)>|<ca.mcgill.sable.soot.jimple.LocalCopy: int hashCode()><ca.mcgill.sable.util.HashSet: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.StmtGraph: ca.mcgill.sable.soot.jimple.StmtBody getBody()><java.math.MathContext: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.SootClass: void addMethod(ca.mcgill.sable.soot.SootMethod)>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUseBoxes()>|<ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack push(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.Transformations: void removeUnusedLocals(ca.mcgill.sable.soot.jimple.StmtBody)>).*<ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Collection entries()>
.*(<ca.mcgill.sable.soot.jimple.JGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.coffi.TypeArray: void setClassManager(ca.mcgill.sable.soot.SootClassManager)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$22: void handleIntCase()>|<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()><ca.mcgill.sable.util.ArrayList: boolean add(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractSequentialList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.soot.jimple.AbstractIntBinopExpr: ca.mcgill.sable.soot.Type getType()><ca.mcgill.sable.util.LinkedList$LinkedListIterator: boolean hasNext()>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.StmtAddressType: java.lang.String toString()><ca.mcgill.sable.soot.CharType: ca.mcgill.sable.soot.CharType v()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>).*<ca.mcgill.sable.soot.CharType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: void intersection(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>|<ca.mcgill.sable.soot.jimple.TypeResolver: void <init>(ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.soot.jimple.DoubleConstant: ca.mcgill.sable.soot.jimple.DoubleConstant v(double)>).*<ca.mcgill.sable.util.AbstractMap$ValueCollection: ca.mcgill.sable.util.Iterator iterator()>
.*<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>.*(<ca.mcgill.sable.util.LinkedList: void addLast(java.lang.Object)>|<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: int size()>)
.*(<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getDefaultTarget()>).*<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.Iterator iterator()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)><ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()>).*<java.util.Arrays: char[] copyOfRange(char[],int,int)>
.*<ca.mcgill.sable.soot.SootClass: boolean hasSuperClass()>.*<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.coffi.Instruction_New: void <init>()>|<java.util.Hashtable: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JGotoStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.soot.jimple.JIfStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.JReturnStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>.*<ca.mcgill.sable.util.AbstractList: int indexOf(java.lang.Object)>.*(<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.SplayTreeMap)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>)
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>.*<ca.mcgill.sable.soot.ByteType: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JNewArrayExpr: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.JAddExpr: java.lang.String getSymbol()>)
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.io.ObjectStreamField: java.lang.String toString()><java.util.ResourceBundle$CacheKey: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void set(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.coffi.TypeStack: int topIndex()><ca.mcgill.sable.soot.coffi.Instruction_Int2short: void <init>()>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseBreakpointStmt(ca.mcgill.sable.soot.jimple.BreakpointStmt)>
.*(<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UshrExpr newUshrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.LocalCopy: int hashCode()>).*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.jimple.ArraySparseSet: void <init>(ca.mcgill.sable.soot.jimple.ArraySparseSet)>|<ca.mcgill.sable.soot.coffi.Instruction_Athrow: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Ifne: void <init>()>).*<ca.mcgill.sable.util.AbstractCollection: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUseBoxes()><ca.mcgill.sable.util.AbstractMap: java.lang.Object put(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.io.DataInputStream: int readUnsignedShort()><ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void <init>(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.Transformations: void aggregate(ca.mcgill.sable.soot.jimple.StmtBody)><java.net.InterfaceAddress: int hashCode()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.util.List getLookupValues()><ca.mcgill.sable.util.ArrayList: boolean add(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()><java.util.Hashtable: java.util.Enumeration keys()>).*<ca.mcgill.sable.util.VectorSet$VectorIterator: void <init>(ca.mcgill.sable.util.VectorSet)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.util.AbstractList: java.lang.Object set(int,java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lmul: void <init>()>
.*<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>.*<ca.mcgill.sable.soot.jimple.JReturnVoidStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseIntType(ca.mcgill.sable.soot.IntType)>|<java.security.ProtectionDomain: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_int: int parse(byte[],int)><java.net.Inet4Address: int hashCode()>).*<ca.mcgill.sable.soot.coffi.Instruction_Aload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.BuildJimpleBodyOption: boolean noAggregating(int)><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()>).*<ca.mcgill.sable.soot.DoubleType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmpge: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_intvar: int nextOffset(int)>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: int size()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.util.AbstractCollection: boolean addAll(ca.mcgill.sable.util.Collection)>).*<ca.mcgill.sable.soot.IntType: void <clinit>()>
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<sun.reflect.annotation.AnnotationType: java.lang.String toString()><ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction disassemble_bytecode(byte[],int)>|<ca.mcgill.sable.soot.grimp.GShrExpr: java.lang.String getSymbol()><java.io.PrintStream: void println(java.lang.String)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ifgt: void <init>()>
.*(<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>|<ca.mcgill.sable.soot.BooleanType: void apply(ca.mcgill.sable.util.Switch)><java.math.BigInteger: int hashCode()>).*<ca.mcgill.sable.util.AbstractMap$ValueIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GExitMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_byte: void <init>(byte)>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.VirtualInvokeExpr)>|<ca.mcgill.sable.util.ArrayList$ArrayIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.coffi.Instruction_Ireturn: void <init>()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()>.*<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.util.AbstractMap: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.util.ArraySet$ArrayIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void difference(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.LocalStmtPair: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.LongConstant: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: ca.mcgill.sable.util.List getDefBoxes()><ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()>).*<ca.mcgill.sable.soot.grimp.GMulExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.JasminClass$32: void handleIntCase()>).*<ca.mcgill.sable.soot.jimple.JCmpgExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseNeExpr(ca.mcgill.sable.soot.jimple.NeExpr)>|<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.IntConstant: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: ca.mcgill.sable.util.List getExceptionTypes()><ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.grimp.GThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: boolean hasNext()><ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>.*(<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>|<ca.mcgill.sable.soot.jimple.AbstractVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])>)
.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.coffi.Instruction_Aastore: void <init>()>)
.*<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>.*(<ca.mcgill.sable.soot.jimple.JNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)>|<ca.mcgill.sable.util.LinkedList: void addFirst(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateConstrains()>|<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseParameterRef(ca.mcgill.sable.soot.jimple.ParameterRef)><ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void copy(java.lang.Object,java.lang.Object)>).*<java.text.FieldPosition: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$32: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>).*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: ca.mcgill.sable.soot.Type getBaseType()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()>|<ca.mcgill.sable.soot.jimple.Local: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JRemExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.UnitBox newStmtBox(ca.mcgill.sable.soot.jimple.Unit)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.coffi.Instruction_Monitorexit: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Lload_1: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Anewarray: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.AbstractSet: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$16: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.util.AbstractMap: boolean containsKey(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: long convert()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmpExpr newCmpExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.TypeStack: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.coffi.Instruction_intbranch: void offsetToPointer(ca.mcgill.sable.soot.coffi.ByteCode)><java.text.NumberFormat: void <clinit>()>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddParent(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>.*<ca.mcgill.sable.util.AbstractMap$AbstractEntry: int hashCode()>.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.util.StringTokenizer: java.lang.Object nextElement()>)
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalUses: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph,ca.mcgill.sable.soot.jimple.LocalDefs)>|<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.Long2ndHalfType: java.lang.String toString()>).*<ca.mcgill.sable.util.SplayTreeMap: java.lang.Object get(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.util.LinkedList: void addFirst(java.lang.Object)><ca.mcgill.sable.soot.jimple.IntConstant: void <init>(int)>).*<ca.mcgill.sable.soot.coffi.TypeArray: boolean equals(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>.*<ca.mcgill.sable.soot.jimple.NullConstant: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.util.ConcurrentModificationException: void <init>()>|<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.Object getValue()>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: void apply(ca.mcgill.sable.util.Switch)><java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.util.AbstractMap$KeyIterator: void remove()>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_2: void <init>()><ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.Collections$UnmodIterator: java.lang.Object next()><java.net.Proxy: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.LongConstant: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.grimp.GrimpTransformations: void foldConstructors(ca.mcgill.sable.soot.grimp.GrimpBody)>|<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: boolean hasNext()><ca.mcgill.sable.soot.SootClass: void resolve()>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: void remove()>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseRefType(ca.mcgill.sable.soot.RefType)>|<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)><ca.mcgill.sable.soot.coffi.ByteCode: void <init>()>).*<ca.mcgill.sable.util.AbstractList: java.lang.Object set(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.RemExpr newRemExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.AbstractMap$ValueCollection: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.soot.jimple.ConditionExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GExitMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.Type get(int)>).*<ca.mcgill.sable.soot.coffi.BasicBlock: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>|<java.util.ResourceBundle$CacheKey: int hashCode()><ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)>).*<ca.mcgill.sable.soot.jimple.JRetStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>
.*<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.coffi.ClassFile: boolean loadClassFile()>.*(<java.net.SocketPermission: boolean equals(java.lang.Object)>|<ca.mcgill.sable.soot.jimple.LocalCopy: int hashCode()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void collapseStronglyConnectedComponents()>|<java.util.Vector: int hashCode()><ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.SootClass: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LeExpr newLeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.IntSet: void grow()>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$24: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.coffi.Instruction_noargs: void <init>(byte)><ca.mcgill.sable.soot.jimple.LocalSplitter: void splitLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>).*<ca.mcgill.sable.soot.UnknownType: java.lang.String toString()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateArrayConstraints()>.*<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*(<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getKey()>|<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toBriefString()>)
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.soot.coffi.Generic_attribute: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$26: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.FloatType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.jimple.JasminClass$26: void <init>(ca.mcgill.sable.soot.jimple.JasminClass)><ca.mcgill.sable.soot.jimple.GroupIntPair: int hashCode()>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.IfStmt newIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>
.*(<ca.mcgill.sable.util.ArraySet$ArrayIterator: void <init>(ca.mcgill.sable.util.ArraySet)>|<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: java.lang.String toBriefString()><ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toBriefString()>).*<ca.mcgill.sable.util.Collections$UnmodList: int hashCode()>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()><ca.mcgill.sable.soot.coffi.BBQ: void push(ca.mcgill.sable.soot.coffi.BasicBlock)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Ldc2w: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.grimp.GLtExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.ByteType: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<sun.util.calendar.Era: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toBriefString()>).*<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: ca.mcgill.sable.util.List getUnitBoxes()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<java.util.AbstractMap: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Dup2_x1: void <init>()>
.*(<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: void remove()>|<java.net.Proxy: java.lang.String toString()><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.soot.ErroneousType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.jimple.TypeResolver: boolean access$3()><ca.mcgill.sable.soot.coffi.Instruction_Lookupswitch: void <init>()>).*<ca.mcgill.sable.soot.ErroneousType: void <init>()>
.*(<ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JasminClass$14: void caseReturnStmt(ca.mcgill.sable.soot.jimple.ReturnStmt)>).*<ca.mcgill.sable.soot.coffi.Instruction_Fastore: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.Main: java.lang.String paddedLeftOf(java.lang.String,int)>|<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_Frem: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.jimple.JasminClass$32: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)><ca.mcgill.sable.soot.coffi.Instruction_Iload_1: void <init>()>).*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JTrap: ca.mcgill.sable.soot.jimple.Unit getEndUnit()>).*<ca.mcgill.sable.soot.coffi.ByteCode: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<java.util.BitSet: void or(java.util.BitSet)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseThisRef(ca.mcgill.sable.soot.jimple.ThisRef)>).*<ca.mcgill.sable.soot.jimple.JNegExpr: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JStaticInvokeExpr: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.grimp.GShrExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[],int[],ca.mcgill.sable.soot.jimple.TypeResolver)><ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Lcmp: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootClass getSuperClass()>|<ca.mcgill.sable.soot.coffi.Instruction_Iconst_1: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ret: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Double2ndHalfType: ca.mcgill.sable.soot.coffi.Double2ndHalfType v()><ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)>).*<ca.mcgill.sable.soot.grimp.AbstractGrimpFloatBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()><ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>).*<ca.mcgill.sable.soot.StmtAddressType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Laload: void <init>()><ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.util.ClassLocator: java.io.InputStream getInputStreamOf(java.lang.String,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_D2l: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getParent()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.XorExpr newXorExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.LinkedList$Node: ca.mcgill.sable.util.LinkedList$Node getNext()>).*<ca.mcgill.sable.soot.jimple.AbstractLengthExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)>|<sun.util.calendar.CalendarDate: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.coffi.Instruction_Anewarray: void <init>()>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseRefType(ca.mcgill.sable.soot.RefType)><ca.mcgill.sable.soot.coffi.Instruction_Ifle: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_intindex: void <init>(byte)>
.*(<ca.mcgill.sable.soot.jimple.JUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction: int hashCode()><ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>).*<java.util.StringTokenizer: java.lang.Object nextElement()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)>.*<ca.mcgill.sable.soot.grimp.GCmplExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.AbstractExprSwitch: void <init>()>|<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.coffi.ClassFile: ca.mcgill.sable.soot.coffi.Instruction parseMethod(ca.mcgill.sable.soot.coffi.method_info)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph,ca.mcgill.sable.soot.jimple.LiveLocals)>).*<ca.mcgill.sable.soot.jimple.JasminClass: void okayEmit(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLocal(ca.mcgill.sable.soot.jimple.Local)><ca.mcgill.sable.soot.jimple.JasminClass$35: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$19: void caseCharType(ca.mcgill.sable.soot.CharType)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseNewArrayExpr(ca.mcgill.sable.soot.jimple.NewArrayExpr)>).*<ca.mcgill.sable.util.ArrayList: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$22: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.Instruction_longbranch: ca.mcgill.sable.soot.coffi.Instruction[] branchpoints(ca.mcgill.sable.soot.coffi.Instruction)>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: int getLowIndex()>
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: void <init>(java.lang.Object[],int)><ca.mcgill.sable.soot.jimple.JasminClass$32: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getInterfaces()>|<ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmplExpr newCmplExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Newarray: int parse(byte[],int)>
.*<ca.mcgill.sable.soot.DoubleType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*(<ca.mcgill.sable.soot.grimp.GXorExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>|<sun.misc.SoftCache: java.lang.Object get(java.lang.Object)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)><ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.ShortType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)><ca.mcgill.sable.soot.jimple.FastColorer$InterferenceGraph: void <init>(ca.mcgill.sable.soot.jimple.FastColorer,ca.mcgill.sable.soot.jimple.StmtBody,ca.mcgill.sable.util.Map,ca.mcgill.sable.soot.jimple.LiveLocals)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>.*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<java.util.Vector: void insertElementAt(java.lang.Object,int)>)
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void handleIntCase()><ca.mcgill.sable.util.ArrayList: java.lang.Object[] toArray()>).*<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootMethod getMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.ExitMonitorStmt newExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)><ca.mcgill.sable.soot.coffi.Instruction_If_acmpne: void <init>()>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString(java.lang.String,ca.mcgill.sable.soot.jimple.Value,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dup2_x1: void <init>()><ca.mcgill.sable.soot.coffi.Double2ndHalfType: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_byteindex: void <init>(byte)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void removeIndirectRelations()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InstanceOfExpr newInstanceOfExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)><java.io.PrintWriter: void println(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JSubExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.LocalCopy: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Local)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseNullType(ca.mcgill.sable.soot.NullType)>).*<java.security.PermissionCollection: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)>|<ca.mcgill.sable.soot.grimp.GNewMultiArrayExpr: void <init>(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)><java.math.BigInteger: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Iload_1: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddChild(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)>
.*(<ca.mcgill.sable.soot.jimple.Transformations: void assignTypesToLocals(ca.mcgill.sable.soot.jimple.JimpleBody)>|<ca.mcgill.sable.soot.grimp.GCastExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.Instruction_byte: int parse(byte[],int)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ConstructorChooser: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>
.*(<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.ClassFile: ca.mcgill.sable.soot.ClassFile v()><java.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_bytevar: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.SootField: java.lang.String getSignature()><ca.mcgill.sable.soot.jimple.JasminClass$30: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecr()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void merge(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>.*<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>.*(<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void remove()>|<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Map$Entry)>)
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCmpgExpr(ca.mcgill.sable.soot.jimple.CmpgExpr)><ca.mcgill.sable.soot.jimple.JasminClass$36: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()>
.*(<ca.mcgill.sable.soot.StoredBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: boolean add(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.SparseLocalDefs$LocalStmtPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_L2f: void <init>()><ca.mcgill.sable.soot.grimp.GTableSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,int,int,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.grimp.Grimp: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitStmt(ca.mcgill.sable.soot.jimple.Stmt)>|<java.util.AbstractMap: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UnitBox newStmtBox(ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.jimple.Local: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.HashSet: boolean remove(java.lang.Object)><ca.mcgill.sable.soot.coffi.CFG: void JsrEliminate()>).*<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseCharType(ca.mcgill.sable.soot.CharType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: int argCountOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.Timer: void start()><ca.mcgill.sable.soot.coffi.BBQ: void push(ca.mcgill.sable.soot.coffi.BasicBlock)>).*<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.grimp.GDivExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$32: void handleIntCase()><ca.mcgill.sable.soot.coffi.Instruction_Invokenonvirtual: void <init>()>).*<ca.mcgill.sable.soot.grimp.GCastExpr: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.util.Collections$UnmodList: java.lang.Object set(int,java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$25: void caseByteType(ca.mcgill.sable.soot.ByteType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseNullType(ca.mcgill.sable.soot.NullType)><ca.mcgill.sable.soot.coffi.CFG: void generateJimpleForCPEntry(ca.mcgill.sable.soot.coffi.cp_info[],int,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$37: void handleIntCase()>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractList: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$15: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.RefType: ca.mcgill.sable.soot.RefType v(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.JThrowStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: boolean resolve()>|<ca.mcgill.sable.soot.grimp.GNewArrayExpr: void <init>(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>).*<ca.mcgill.sable.soot.TypeSwitch: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>
.*(<ca.mcgill.sable.soot.jimple.LocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>|<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.jimple.ValueBox[])><ca.mcgill.sable.soot.jimple.JNeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<java.util.ResourceBundle$CacheKey: java.lang.Object clone()>
.*(<ca.mcgill.sable.soot.jimple.BackwardFlowAnalysis: void doAnalysis()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)><java.text.DecimalFormatSymbols: int hashCode()>).*<ca.mcgill.sable.soot.RefType: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$SCC: void <init>(java.util.Vector)>|<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.TypeResolver$1$RecursiveFunction: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[],int[],ca.mcgill.sable.soot.jimple.TypeResolver)>).*<java.nio.charset.CoderResult: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.jimple.SimpleLocalUses: ca.mcgill.sable.util.List getUsesOf(ca.mcgill.sable.soot.jimple.DefinitionStmt)><ca.mcgill.sable.soot.StmtAddressType: int hashCode()>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseLongType(ca.mcgill.sable.soot.LongType)>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable ecr()><ca.mcgill.sable.util.AbstractMap$KeyIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Double_info: double convert()>
.*<ca.mcgill.sable.soot.coffi.Util: void resolveClass(ca.mcgill.sable.soot.SootClass)>.*<ca.mcgill.sable.soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseShortType(ca.mcgill.sable.soot.ShortType)>|<java.nio.charset.CodingErrorAction: java.lang.String toString()>)
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIdentityStmt(ca.mcgill.sable.soot.jimple.IdentityStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass$25: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.JReturnVoidStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>).*<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseLongType(ca.mcgill.sable.soot.LongType)>|<ca.mcgill.sable.soot.SootClass: java.lang.String getName()><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>).*<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.BasicBlock cloneJsrTargetBB(ca.mcgill.sable.soot.coffi.BasicBlock,ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.coffi.Instruction_intbranch: void offsetToPointer(ca.mcgill.sable.soot.coffi.ByteCode)><java.text.DecimalFormatSymbols: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JOrExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: java.lang.Object clone()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.coffi.Util: void resolveClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)><ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getInterfaces()>
.*(<ca.mcgill.sable.soot.TypeSwitch: void caseByteType(ca.mcgill.sable.soot.ByteType)>|<java.security.BasicPermission: int hashCode()><ca.mcgill.sable.soot.grimp.GGeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.LongType: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.jimple.JReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction locateInst(int)>).*<ca.mcgill.sable.soot.grimp.ObjExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.JasminClass$9: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.StmtAddressType: ca.mcgill.sable.soot.StmtAddressType v()>).*<ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object set(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddChild(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)><ca.mcgill.sable.soot.grimp.GShrExpr: void apply(ca.mcgill.sable.util.Switch)>).*<java.util.regex.Matcher: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.SootMethod: void setModifiers(int)><ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: void copy(java.lang.Object,java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>|<ca.mcgill.sable.soot.SootClass: void setResolved(boolean)><java.io.PrintWriter: void println(java.lang.String)>).*<java.util.AbstractList: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet: void intersection(ca.mcgill.sable.soot.jimple.FlowSet,ca.mcgill.sable.soot.jimple.FlowSet)><ca.mcgill.sable.soot.coffi.CONSTANT_Methodref_info: void <init>()>).*<ca.mcgill.sable.soot.jimple.JasminClass$8: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseThrowStmt(ca.mcgill.sable.soot.jimple.ThrowStmt)>|<ca.mcgill.sable.soot.RefType: java.lang.String toString()><java.util.jar.Attributes$Name: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLocalDefs: void <init>(ca.mcgill.sable.soot.jimple.CompleteStmtGraph)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getTarget(int)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver,ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.util.AbstractList$AbstractListIterator: void <init>(ca.mcgill.sable.util.AbstractList,int)>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JThrowStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)><ca.mcgill.sable.soot.coffi.Instruction_Iload_0: void <init>()>).*<ca.mcgill.sable.soot.jimple.StmtValueBoxPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseCaughtExceptionRef(ca.mcgill.sable.soot.jimple.CaughtExceptionRef)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr newInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<java.util.Arrays: char[] copyOfRange(char[],int,int)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.coffi.Instruction_If_acmpeq: void <init>()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>).*<ca.mcgill.sable.soot.jimple.JGotoStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseOrExpr(ca.mcgill.sable.soot.jimple.OrExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseEnterMonitorStmt(ca.mcgill.sable.soot.jimple.EnterMonitorStmt)><ca.mcgill.sable.soot.grimp.GInstanceFieldRef: int getPrecedence()>).*<ca.mcgill.sable.soot.jimple.JasminClass$25: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.grimp.GGtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$30: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.util.HashSet: ca.mcgill.sable.util.Iterator iterator()>).*<ca.mcgill.sable.soot.coffi.BasicBlock: int hashCode()>
.*(<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.OutFlow processFlow(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[])>|<ca.mcgill.sable.soot.jimple.JasminClass$36: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.Instruction_Fconst_1: void <init>()>).*<ca.mcgill.sable.util.ArrayList: boolean add(java.lang.Object)>
.*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JDivExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.coffi.Instruction_Daload: void <init>()>|<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>)
.*(<ca.mcgill.sable.soot.jimple.AbstractSpecialInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dstore_3: void <init>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.EqExpr newEqExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseUnknownType(ca.mcgill.sable.soot.UnknownType)>
.*(<ca.mcgill.sable.soot.jimple.JCmplExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Ldiv: void <init>()><ca.mcgill.sable.soot.jimple.NullConstant: java.lang.String toString()>).*<ca.mcgill.sable.soot.coffi.Instruction_Idiv: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.util.zip.ZipFile: java.util.zip.ZipEntry getEntry(java.lang.String)><ca.mcgill.sable.soot.jimple.JReturnStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.soot.grimp.GSubExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Dconst_0: void <init>()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.InvokeStmt newInvokeStmt(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.util.AbstractList: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>|<ca.mcgill.sable.soot.jimple.AbstractJimpleIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: boolean hasAncestor(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.soot.jimple.JasminClass$24: void handleIntCase()>
.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>.*<ca.mcgill.sable.soot.jimple.AbstractCastExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.Type getParameterType(int)>|<ca.mcgill.sable.soot.jimple.JEnterMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>|<java.util.Hashtable: java.util.Enumeration keys()><ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy getClassHierarchy(ca.mcgill.sable.soot.SootClassManager)>).*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.StaticFieldRef: java.lang.String toBriefString()><ca.mcgill.sable.soot.jimple.JasminClass$5: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.IfStmt newIfStmt(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Unit)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)><java.util.BitSet: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractCollection: boolean remove(java.lang.Object)>
.*<ca.mcgill.sable.soot.RefType: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.jimple.JasminClass$3: void defaultCase(ca.mcgill.sable.soot.Type)>.*(<ca.mcgill.sable.soot.jimple.DoubleConstant: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.CONSTANT_InterfaceMethodref_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>)
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<java.math.BigInteger: boolean equals(java.lang.Object)><java.text.DecimalFormatSymbols: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.coffi.Instruction_Ifnull: void <init>()>
.*(<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GCmpExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.coffi.BasicBlock: ca.mcgill.sable.soot.jimple.Stmt getHeadJStmt()>).*<ca.mcgill.sable.soot.SootField: ca.mcgill.sable.soot.SootClass getDeclaringClass()>
.*<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getFields()>.*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()>.*(<java.security.PrivilegedActionException: java.lang.String toString()>|<ca.mcgill.sable.util.Collections$UnmodList: int hashCode()>)
.*(<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.Body getBody(ca.mcgill.sable.soot.BodyRepresentation)>|<ca.mcgill.sable.soot.UnknownType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.HashMap: boolean containsKey(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JUshrExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.NullType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$27: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.coffi.Instruction_Invokevirtual: void <init>()>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Class_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)><java.util.StringTokenizer: void <init>(java.lang.String,java.lang.String,boolean)>).*<ca.mcgill.sable.soot.jimple.AbstractInvokeExpr: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseGeExpr(ca.mcgill.sable.soot.jimple.GeExpr)>|<ca.mcgill.sable.util.TypedSplayTreeMap: java.lang.Object clone()><ca.mcgill.sable.soot.TypeSwitch: void caseNullType(ca.mcgill.sable.soot.NullType)>).*<ca.mcgill.sable.util.AbstractMap: int hashCode()>
.*(<ca.mcgill.sable.soot.grimp.GEqExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.BasicBlock: void <init>(ca.mcgill.sable.soot.coffi.Instruction)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTarget(int,ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.jimple.JasminClass$9: void defaultCase(ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.util.AbstractMap$ValueIterator: void remove()>|<ca.mcgill.sable.soot.coffi.ClassFile: void parse()><ca.mcgill.sable.soot.jimple.JasminClass$10: void caseLongType(ca.mcgill.sable.soot.LongType)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void removeChild(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.Instruction_Lstore_3: void <init>()><ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.ArrayList: void doubleCapacity()>
.*<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>.*<ca.mcgill.sable.soot.jimple.AbstractInterfaceInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>.*(<ca.mcgill.sable.util.AbstractList: ca.mcgill.sable.util.Iterator iterator()>|<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseByteType(ca.mcgill.sable.soot.ByteType)>)
.*(<ca.mcgill.sable.soot.grimp.GLeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><ca.mcgill.sable.soot.jimple.JasminClass$34: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.jimple.JRemExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String jasminDescriptorOf(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.coffi.Instruction_If_icmpne: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int parse(byte[],int)>).*<ca.mcgill.sable.soot.jimple.JasminClass$19: void handleIntCase()>
.*(<ca.mcgill.sable.soot.SootClass: void resolve()>|<ca.mcgill.sable.soot.DeterministicHashMap: java.lang.Object remove(java.lang.Object)><ca.mcgill.sable.soot.jimple.AbstractInstanceOfExpr: ca.mcgill.sable.soot.Type getType()>).*<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>|<java.util.Vector: boolean removeElement(java.lang.Object)><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void set(java.lang.Object)>).*<java.util.Vector: java.util.Enumeration elements()>
.*(<ca.mcgill.sable.soot.coffi.Instruction_intbranch: int parse(byte[],int)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShrExpr(ca.mcgill.sable.soot.jimple.ShrExpr)><ca.mcgill.sable.soot.StmtAddressType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.IntConstant: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.util.List getMethods()>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean isEcrArray()><java.text.DigitList: java.lang.Object clone()>).*<ca.mcgill.sable.soot.SootField: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$10: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.Instruction_Dload_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: ca.mcgill.sable.soot.jimple.Value getBase()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseUshrExpr(ca.mcgill.sable.soot.jimple.UshrExpr)>|<ca.mcgill.sable.soot.jimple.JAndExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseDivExpr(ca.mcgill.sable.soot.jimple.DivExpr)>).*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddParent(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Sipush: void <init>()><ca.mcgill.sable.soot.NoSuchMethodException: void <init>(java.lang.String)>).*<java.io.File: boolean equals(java.lang.Object)>
