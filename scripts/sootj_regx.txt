.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type jimpleTypeOfFieldDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AndExpr newAndExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.GroupIntPair: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLtExpr(ca.mcgill.sable.soot.jimple.LtExpr)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.jimple.Local getLocalForStackOp(ca.mcgill.sable.soot.jimple.JimpleBody,ca.mcgill.sable.soot.coffi.TypeStack,int)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseLookupSwitchStmt(ca.mcgill.sable.soot.jimple.LookupSwitchStmt)>).*<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void redirectJumps(ca.mcgill.sable.soot.jimple.Stmt,ca.mcgill.sable.soot.jimple.Stmt)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ThisRef newThisRef(ca.mcgill.sable.soot.SootClass)><ca.mcgill.sable.soot.jimple.JExitMonitorStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.TypeArray: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Istore: void <init>()><ca.mcgill.sable.soot.jimple.JasminClass$23: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>
.*(<ca.mcgill.sable.soot.coffi.ClassFile: boolean readClass(java.io.DataInputStream)>|<ca.mcgill.sable.util.AbstractList: java.lang.Object set(int,java.lang.Object)><ca.mcgill.sable.soot.jimple.JGotoStmt: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.SplayTreeMap)>
.*(<ca.mcgill.sable.soot.jimple.JReturnStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JThrowStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.ArrayType: ca.mcgill.sable.soot.ArrayType v(ca.mcgill.sable.soot.BaseType,int)>).*<ca.mcgill.sable.soot.coffi.Instruction_Aload: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.NewArrayExpr newNewArrayExpr(ca.mcgill.sable.soot.Type,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$15: void caseFloatType(ca.mcgill.sable.soot.FloatType)>).*<ca.mcgill.sable.soot.jimple.AbstractStmtSwitch: void caseExitMonitorStmt(ca.mcgill.sable.soot.jimple.ExitMonitorStmt)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitValue(ca.mcgill.sable.soot.jimple.Value)>|<ca.mcgill.sable.soot.grimp.ExprBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.AbstractSequentialList: java.lang.Object get(int)>).*<ca.mcgill.sable.util.IntSet: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)>|<ca.mcgill.sable.soot.coffi.Util: void setClassNameToAbbreviation(ca.mcgill.sable.util.Map)><java.util.ArrayList: java.lang.Object clone()>).*<ca.mcgill.sable.soot.jimple.JasminClass: void emitAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>
.*(<ca.mcgill.sable.soot.jimple.ClassHierarchy: ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode getTypeNode(ca.mcgill.sable.soot.Type)>|<java.security.PrivilegedActionException: java.lang.String toString()><java.util.AbstractMap: int hashCode()>).*<ca.mcgill.sable.soot.jimple.Main: void <clinit>()>
.*(<ca.mcgill.sable.soot.SootClass: ca.mcgill.sable.soot.SootMethod getMethod(java.lang.String,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.grimp.GShlExpr: java.lang.String getSymbol()><java.util.AbstractMap: java.lang.String toString()>).*<ca.mcgill.sable.util.Collections$UnmodList: int hashCode()>
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>.*<ca.mcgill.sable.soot.jimple.LocalCopy: java.lang.String toString()>.*(<ca.mcgill.sable.soot.jimple.AbstractNewMultiArrayExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.IntType: void apply(ca.mcgill.sable.util.Switch)>)
.*(<ca.mcgill.sable.soot.TrustingMonotonicArraySet$ArrayIterator: void remove()>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)><ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.SplayTreeMap$Node find(java.lang.Object)>).*<ca.mcgill.sable.util.UnsupportedOperationException: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.jimple.Local getLocalForIndex(ca.mcgill.sable.soot.jimple.JimpleBody,int)><ca.mcgill.sable.soot.grimp.GSpecialInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$1: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>
.*(<ca.mcgill.sable.soot.StoredBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>|<ca.mcgill.sable.soot.coffi.Instruction_Lshr: void <init>()><ca.mcgill.sable.util.Collections$UnmodIterator: void remove()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void removeChild(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.grimp.Grimp$1: void caseMulExpr(ca.mcgill.sable.soot.jimple.MulExpr)><ca.mcgill.sable.soot.Modifier: java.lang.String toString(int)>).*<sun.util.calendar.CalendarDate: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.SparseLiveLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NopStmt newNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)><ca.mcgill.sable.soot.jimple.AbstractBinopExpr: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: boolean hasNext()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.AndExpr newAndExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>).*<java.util.jar.Attributes: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCastExpr(ca.mcgill.sable.soot.jimple.CastExpr)>|<java.io.ObjectInputStream$PeekInputStream: void close()><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object clone()>).*<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)>
.*(<ca.mcgill.sable.soot.jimple.SimpleLiveLocalsAnalysis: void <init>(ca.mcgill.sable.soot.jimple.StmtGraph)>|<ca.mcgill.sable.soot.jimple.JasminClass$3: void caseArrayType(ca.mcgill.sable.soot.ArrayType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newVariableBox(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Double2ndHalfType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$31: void caseBooleanType(ca.mcgill.sable.soot.BooleanType)>|<ca.mcgill.sable.soot.SootClassManager: ca.mcgill.sable.soot.SootClass getClass(java.lang.String)><java.io.FileInputStream: void close()>).*<ca.mcgill.sable.util.AbstractList: void add(int,java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.NoSuperClassException: void <init>()><java.net.SocketPermission: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.AbstractList: boolean add(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.GNewInvokeExpr: java.lang.String toString()>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.VirtualInvokeExpr newVirtualInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>).*<ca.mcgill.sable.util.SplayTreeMap: void splay(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.DeterministicHashMap: ca.mcgill.sable.util.Set keySet()><ca.mcgill.sable.soot.jimple.JasminClass$34: void caseIntType(ca.mcgill.sable.soot.IntType)>).*<ca.mcgill.sable.soot.SootMethod: java.lang.String getSignature()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void propagateConstrains()>|<ca.mcgill.sable.soot.ErroneousType: int hashCode()><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void setTargets(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.jimple.JasminClass$20: void caseIntType(ca.mcgill.sable.soot.IntType)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitValue(ca.mcgill.sable.soot.jimple.Value)>|<java.util.Formatter: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<java.io.DataInputStream: int readUnsignedShort()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAndExpr(ca.mcgill.sable.soot.jimple.AndExpr)>|<ca.mcgill.sable.util.VectorSet: ca.mcgill.sable.util.Iterator iterator()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.Local newLocal(java.lang.String,ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$36: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.ConstantAndCopyPropagator: void propagateConstantsAndCopies(ca.mcgill.sable.soot.jimple.StmtBody)>|<ca.mcgill.sable.soot.Modifier: boolean isProtected(int)><ca.mcgill.sable.soot.coffi.Instruction_Dup2_x2: void <init>()>).*<ca.mcgill.sable.soot.jimple.StmtBox: ca.mcgill.sable.soot.jimple.Unit getUnit()>
.*(<ca.mcgill.sable.soot.jimple.Main: void main(java.lang.String[])>|<ca.mcgill.sable.soot.jimple.JasminClass$13: void caseIntType(ca.mcgill.sable.soot.IntType)><ca.mcgill.sable.soot.coffi.Instruction: int nextOffset(int)>).*<ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: void <init>(ca.mcgill.sable.soot.jimple.ClassHierarchy,ca.mcgill.sable.soot.Type)>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getValue()><ca.mcgill.sable.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)>).*<java.net.InetAddress: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.SourceFile_attribute: void <init>()><ca.mcgill.sable.soot.FloatType: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.coffi.Instruction: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_0: void <init>()><java.util.Hashtable$Entry: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<java.util.Vector: java.lang.Object elementAt(int)><ca.mcgill.sable.soot.jimple.StmtBox: void setUnit(ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.SootMethod: ca.mcgill.sable.soot.SootClass getDeclaringClass()>
.*(<ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JIfStmt: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.UnitBox)><ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.UnitBox[] getTargetBoxesArray(ca.mcgill.sable.util.List)>).*<ca.mcgill.sable.soot.grimp.GEqExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseCmplExpr(ca.mcgill.sable.soot.jimple.CmplExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void <init>(ca.mcgill.sable.soot.jimple.TypeResolver)><java.util.jar.Manifest$FastInputStream: void close()>).*<ca.mcgill.sable.soot.grimp.GrimpBody$1: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Baload: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Aastore: void <init>()>).*<java.io.File: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JExitMonitorStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.jimple.JRemExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.HashMap$HashEntry: void <init>(ca.mcgill.sable.util.HashMap,java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GGeExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.coffi.Instruction_Fstore_1: void <init>()><ca.mcgill.sable.soot.ShortType: void <init>()>).*<ca.mcgill.sable.util.HashMap$HashEntry: java.lang.Object getValue()>
.*(<ca.mcgill.sable.soot.jimple.Main: void handleClass(ca.mcgill.sable.soot.SootClass,java.lang.String,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.JasminClass: java.lang.String slashify(java.lang.String)><ca.mcgill.sable.soot.jimple.JasminClass: void print(java.io.PrintWriter)>).*<ca.mcgill.sable.soot.jimple.JasminClass$33: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.jimple.JMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.jimple.Local getLocalCreatingIfNecessary(ca.mcgill.sable.soot.jimple.JimpleBody,java.lang.String,ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.jimple.ArrayPackedSet: java.lang.Object clone()>).*<sun.util.calendar.Era: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>|<ca.mcgill.sable.soot.grimp.AbstractGrimpIntBinopExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.jimple.ValueBox)><ca.mcgill.sable.soot.jimple.JasminClass$18: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<java.io.InputStream: void close()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.coffi.BBQ: void push(ca.mcgill.sable.soot.coffi.BasicBlock)>).*<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JRetStmt: java.lang.String toString(boolean,ca.mcgill.sable.util.Map,java.lang.String)>|<ca.mcgill.sable.soot.coffi.Instruction_intvar: void <init>(byte)><ca.mcgill.sable.soot.coffi.Util: ca.mcgill.sable.soot.Type jimpleTypeOfFieldDescriptor(ca.mcgill.sable.soot.SootClassManager,java.lang.String)>).*<ca.mcgill.sable.util.Collections$UnmodIterator: void <init>(ca.mcgill.sable.util.Iterator)>
.*<ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>.*<ca.mcgill.sable.soot.grimp.Grimp$1: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>.*(<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>|<ca.mcgill.sable.soot.coffi.BBQ: void push(ca.mcgill.sable.soot.coffi.BasicBlock)>)
.*(<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JShrExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$5: void caseGtExpr(ca.mcgill.sable.soot.jimple.GtExpr)>).*<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseInterfaceInvokeExpr(ca.mcgill.sable.soot.jimple.InterfaceInvokeExpr)>
.*(<ca.mcgill.sable.soot.jimple.JAndExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>).*<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LtExpr newLtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.coffi.Instruction_Ineg: void <init>()>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void removeChild(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass: void emitAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)>|<ca.mcgill.sable.soot.SootMethod: void setParameterTypes(ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.jimple.LocalCopy: java.lang.String toString()>).*<ca.mcgill.sable.soot.jimple.VariableBox: boolean canContainValue(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseLocal(ca.mcgill.sable.soot.jimple.Local)>|<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseRetStmt(ca.mcgill.sable.soot.jimple.RetStmt)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.RemExpr newRemExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()>
.*(<ca.mcgill.sable.soot.grimp.GUshrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.SplayTreeMap: int compare(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$13: void <init>(java.lang.String,ca.mcgill.sable.soot.jimple.JasminClass)>).*<ca.mcgill.sable.soot.SootClassManager: boolean managesClass(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.soot.SootMethod: void setSource(ca.mcgill.sable.soot.coffi.ClassFile,ca.mcgill.sable.soot.coffi.method_info)><ca.mcgill.sable.soot.jimple.JLeExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.jimple.ParameterRef: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.SootClass: boolean declaresField(java.lang.String,ca.mcgill.sable.soot.Type)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.LeExpr newLeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.EnterMonitorStmt newEnterMonitorStmt(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Utf8_info: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseSubExpr(ca.mcgill.sable.soot.jimple.SubExpr)>|<ca.mcgill.sable.util.LinkedList: int size()><ca.mcgill.sable.soot.jimple.JasminClass$33: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseAddExpr(ca.mcgill.sable.soot.jimple.AddExpr)>
.*(<ca.mcgill.sable.util.TypedSplayTreeMap: java.lang.Object clone()>|<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: java.lang.Object next()>
.*(<ca.mcgill.sable.soot.ArrayType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.InvokeStmt newInvokeStmt(ca.mcgill.sable.soot.jimple.InvokeStmt)><ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[] getEcrParents()>).*<ca.mcgill.sable.soot.StmtAddressType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.RefType: void apply(ca.mcgill.sable.util.Switch)>|<java.net.Proxy: int hashCode()><ca.mcgill.sable.soot.jimple.NullConstant: void <init>()>).*<ca.mcgill.sable.soot.SootClass: void addField(ca.mcgill.sable.soot.SootField)>
.*(<ca.mcgill.sable.soot.jimple.StmtBox: void <init>(ca.mcgill.sable.soot.jimple.Stmt)>|<java.util.HashMap: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JasminClass$19: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.util.SplayTreeMap$Node: void removeChild(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: boolean mergeAll(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)>|<java.util.AbstractMap: int hashCode()><ca.mcgill.sable.util.Collections$UnmodList: boolean add(java.lang.Object)>).*<ca.mcgill.sable.soot.grimp.GExitMonitorStmt: void <init>(ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable getTypeVariable(ca.mcgill.sable.soot.Type)>|<java.io.FileInputStream: void <clinit>()><java.io.FileInputStream: void close()>).*<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseStaticFieldRef(ca.mcgill.sable.soot.jimple.StaticFieldRef)>|<ca.mcgill.sable.soot.jimple.JCaughtExceptionRef: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.SparseLocalDefs$LocalStmtPair: int hashCode()>).*<ca.mcgill.sable.soot.DoubleType: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$21: void caseIntType(ca.mcgill.sable.soot.IntType)>|<ca.mcgill.sable.soot.jimple.JArrayRef: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.AbstractLengthExpr: void <init>(ca.mcgill.sable.soot.jimple.ValueBox)>).*<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>
.*(<ca.mcgill.sable.soot.jimple.JGotoStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Int2char: void <init>()><ca.mcgill.sable.util.VectorList: int size()>).*<java.util.jar.Attributes$Name: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.grimp.GArrayRef: java.lang.String toBriefString()>|<ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseStaticInvokeExpr(ca.mcgill.sable.soot.jimple.StaticInvokeExpr)><ca.mcgill.sable.soot.jimple.JasminClass$28: void caseRefType(ca.mcgill.sable.soot.RefType)>).*<ca.mcgill.sable.soot.coffi.CONSTANT_Long_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>
.*(<ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)><ca.mcgill.sable.soot.jimple.JIdentityStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Long2ndHalfType: java.lang.String toString()><ca.mcgill.sable.soot.grimp.Grimp$1: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>).*<ca.mcgill.sable.soot.jimple.JasminClass$28: void caseByteType(ca.mcgill.sable.soot.ByteType)>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody$2: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>|<ca.mcgill.sable.soot.jimple.JasminClass: void print(java.io.PrintWriter)><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseGotoStmt(ca.mcgill.sable.soot.jimple.GotoStmt)>).*<ca.mcgill.sable.util.AbstractMap$KeyIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>
.*(<ca.mcgill.sable.soot.grimp.GOrExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.LocalSplitter: void splitLocals(ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.soot.jimple.ThisRef: ca.mcgill.sable.util.List getUseBoxes()>).*<ca.mcgill.sable.soot.grimp.GCmpExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.coffi.Util: void resolveClass(ca.mcgill.sable.soot.SootClass)>|<ca.mcgill.sable.soot.VoidType: int hashCode()><ca.mcgill.sable.util.ConcurrentModificationException: void <init>()>).*<java.text.ParsePosition: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$7: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.JasminClass$34: void caseShortType(ca.mcgill.sable.soot.ShortType)><ca.mcgill.sable.soot.jimple.Local: void setName(java.lang.String)>).*<ca.mcgill.sable.soot.jimple.AbstractBinopExpr: ca.mcgill.sable.soot.jimple.Value getOp1()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$2: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>|<ca.mcgill.sable.soot.jimple.ArraySparseSet$SparseArrayList: int size()><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LengthExpr newLengthExpr(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.coffi.Instruction_Iinc: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: int getEcrId()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void caseDoubleConstant(ca.mcgill.sable.soot.jimple.DoubleConstant)>).*<ca.mcgill.sable.soot.LongType: void <clinit>()>
.*(<ca.mcgill.sable.soot.grimp.GMulExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JLookupSwitchStmt: ca.mcgill.sable.soot.jimple.Unit getDefaultTarget()><ca.mcgill.sable.soot.jimple.JasminClass$13: void defaultCase(ca.mcgill.sable.soot.Type)>).*<ca.mcgill.sable.soot.coffi.Instruction_Faload: void <init>()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void handleInvokeExpr(ca.mcgill.sable.soot.jimple.InvokeExpr)>|<ca.mcgill.sable.util.AbstractList: boolean add(java.lang.Object)><ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>).*<ca.mcgill.sable.soot.jimple.AbstractNegExpr: ca.mcgill.sable.soot.Type getType()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseIfStmt(ca.mcgill.sable.soot.jimple.IfStmt)>|<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable[] getEcrParents()><ca.mcgill.sable.soot.jimple.AbstractJimpleValueSwitch: void defaultCase(java.lang.Object)>).*<ca.mcgill.sable.soot.jimple.JasminClass$16: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>
.*(<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)>|<ca.mcgill.sable.soot.VoidType: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseCharType(ca.mcgill.sable.soot.CharType)>).*<ca.mcgill.sable.soot.DoubleType: ca.mcgill.sable.soot.DoubleType v()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$4: void caseArrayType(ca.mcgill.sable.soot.ArrayType)>|<ca.mcgill.sable.soot.jimple.JasminClass$29: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.RetStmt newRetStmt(ca.mcgill.sable.soot.jimple.Value)>).*<ca.mcgill.sable.soot.RefType: void <init>(java.lang.String)>
.*(<ca.mcgill.sable.soot.jimple.AbstractStaticInvokeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JimpleBody: void addTrap(ca.mcgill.sable.soot.jimple.Trap)><ca.mcgill.sable.soot.coffi.TypeStack: ca.mcgill.sable.soot.coffi.TypeStack pop()>).*<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseShortType(ca.mcgill.sable.soot.ShortType)>
.*(<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<java.security.Timestamp: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Dneg: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Getfield: void <init>()>
.*(<ca.mcgill.sable.soot.SootClass: void printTo(ca.mcgill.sable.soot.BodyExpr,java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NewMultiArrayExpr newNewMultiArrayExpr(ca.mcgill.sable.soot.ArrayType,ca.mcgill.sable.util.List)><ca.mcgill.sable.soot.coffi.TypeStack: void <init>()>).*<ca.mcgill.sable.soot.jimple.Jimple: void <clinit>()>
.*(<ca.mcgill.sable.util.ArrayList$ArrayIterator: void remove()>|<ca.mcgill.sable.soot.coffi.TypeStack: void setClassManager(ca.mcgill.sable.soot.SootClassManager)><ca.mcgill.sable.soot.grimp.GLtExpr: java.lang.String getSymbol()>).*<ca.mcgill.sable.soot.CharType: boolean equals(java.lang.Object)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseLeExpr(ca.mcgill.sable.soot.jimple.LeExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_Saload: void <init>()><java.util.jar.Manifest: boolean equals(java.lang.Object)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean contains(java.lang.Object)>
.*(<ca.mcgill.sable.soot.jimple.JAssignStmt: void apply(ca.mcgill.sable.util.Switch)>|<java.util.BitSet: void set(int)><ca.mcgill.sable.soot.jimple.Main: java.lang.String toTimeString(ca.mcgill.sable.soot.Timer,long)>).*<ca.mcgill.sable.soot.grimp.GShrExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>
.*(<ca.mcgill.sable.soot.jimple.AbstractNewArrayExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Dup: void <init>()><ca.mcgill.sable.soot.jimple.JGotoStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.util.Collections$UnmodList: boolean addAll(ca.mcgill.sable.util.Collection)>
.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceFieldRef(ca.mcgill.sable.soot.jimple.InstanceFieldRef)>.*<ca.mcgill.sable.soot.jimple.LocalCopy: java.lang.String toString()>.*(<ca.mcgill.sable.util.AbstractMap$ValueIterator: void <init>(ca.mcgill.sable.util.AbstractMap)>|<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewMultiArrayExpr(ca.mcgill.sable.soot.jimple.NewMultiArrayExpr)>)
.*(<ca.mcgill.sable.soot.jimple.JGeExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.TypedSplayTreeMap$TypedEntry: java.lang.Object getValue()><ca.mcgill.sable.soot.coffi.CONSTANT_Integer_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>).*<ca.mcgill.sable.soot.grimp.GVirtualInvokeExpr: java.lang.String toBriefString()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseInstanceOfExpr(ca.mcgill.sable.soot.jimple.InstanceOfExpr)>|<ca.mcgill.sable.soot.NullType: void <init>()><ca.mcgill.sable.soot.coffi.Instruction_Dstore_2: void <init>()>).*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: ca.mcgill.sable.soot.jimple.Value getKey()>
.*(<ca.mcgill.sable.soot.DoubleType: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.AbstractInstanceFieldRef: void <init>(ca.mcgill.sable.soot.jimple.ValueBox,ca.mcgill.sable.soot.SootField)><ca.mcgill.sable.soot.ErroneousType: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_Multianewarray: int nextOffset(int)>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void collapseStronglyConnectedComponents()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.UnitBox newStmtBox(ca.mcgill.sable.soot.jimple.Unit)><java.text.DigitList: java.lang.Object clone()>).*<ca.mcgill.sable.soot.grimp.GDivExpr: java.lang.String getSymbol()>
.*(<ca.mcgill.sable.soot.jimple.AbstractNegExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.util.AbstractSet: boolean equals(java.lang.Object)><ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode: boolean hasDescendant(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)>).*<ca.mcgill.sable.soot.grimp.GAddExpr: void apply(ca.mcgill.sable.util.Switch)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.SpecialInvokeExpr)>|<ca.mcgill.sable.soot.jimple.JVirtualInvokeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><ca.mcgill.sable.util.LinkedList$LinkedListIterator: void remove()>).*<ca.mcgill.sable.util.SplayTreeMap: void splay(ca.mcgill.sable.util.SplayTreeMap$Node)>
.*(<ca.mcgill.sable.soot.grimp.Grimp$1: void caseNegExpr(ca.mcgill.sable.soot.jimple.NegExpr)>|<ca.mcgill.sable.soot.jimple.ClassHierarchy$ToInt: void caseByteType(ca.mcgill.sable.soot.ByteType)><ca.mcgill.sable.soot.TrustingMonotonicArraySet: java.lang.Object[] access$1(ca.mcgill.sable.soot.TrustingMonotonicArraySet)>).*<ca.mcgill.sable.soot.ArrayType: java.lang.String toString()>
.*(<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.jimple.JasminClass$20: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.soot.coffi.Instruction_Castore: void <init>()>).*<ca.mcgill.sable.soot.coffi.Instruction_L2i: void <init>()>
.*<ca.mcgill.sable.soot.jimple.JasminClass: void emitMethod(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.BodyExpr)>.*<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseLengthExpr(ca.mcgill.sable.soot.jimple.LengthExpr)>.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewInvokeExpr(ca.mcgill.sable.soot.jimple.NewInvokeExpr)>|<ca.mcgill.sable.util.ArraySet: java.lang.Object[] access$1(ca.mcgill.sable.util.ArraySet)>)
.*(<ca.mcgill.sable.soot.jimple.JasminClass$26: void caseFloatType(ca.mcgill.sable.soot.FloatType)>|<ca.mcgill.sable.soot.jimple.JCmplExpr: java.lang.String getSymbol()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNullConstant(ca.mcgill.sable.soot.jimple.NullConstant)>).*<sun.util.calendar.CalendarDate: int hashCode()>
.*(<ca.mcgill.sable.soot.jimple.JimpleBody: void <init>(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)>|<ca.mcgill.sable.soot.coffi.ByteCode: ca.mcgill.sable.soot.coffi.Instruction locateInst(int)><ca.mcgill.sable.soot.jimple.BuildJimpleBodyOption: boolean noSplitting(int)>).*<java.util.Locale: java.lang.Object clone()>
.*(<ca.mcgill.sable.soot.jimple.TypeResolver: void mergeBaseTypeArrays()>|<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.NeExpr newNeExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.JasminClass$19: void caseShortType(ca.mcgill.sable.soot.ShortType)>).*<ca.mcgill.sable.soot.TypeSwitch: void caseFloatType(ca.mcgill.sable.soot.FloatType)>
.*(<ca.mcgill.sable.soot.jimple.SparseLocalDefsFlowAnalysis: java.lang.Object newInitialFlow()>|<ca.mcgill.sable.soot.jimple.TypeResolver: boolean resolveSingleRelations()><ca.mcgill.sable.soot.coffi.Instruction_Dup2: void <init>()>).*<java.util.StringTokenizer: java.lang.Object nextElement()>
.*(<ca.mcgill.sable.soot.jimple.JasminClass$17: void caseEqExpr(ca.mcgill.sable.soot.jimple.EqExpr)>|<ca.mcgill.sable.soot.coffi.Instruction_noargs: void <init>(byte)><ca.mcgill.sable.soot.jimple.StmtBox: void setUnit(ca.mcgill.sable.soot.jimple.Unit)>).*<ca.mcgill.sable.soot.coffi.Instruction_Astore_0: void <init>()>
.*(<ca.mcgill.sable.soot.grimp.GLtExpr: void apply(ca.mcgill.sable.util.Switch)>|<ca.mcgill.sable.soot.coffi.Instruction_Aload_0: void <init>()><ca.mcgill.sable.util.ArraySet$ArrayIterator: java.lang.Object next()>).*<ca.mcgill.sable.util.IntSet: void grow()>
.*(<ca.mcgill.sable.soot.grimp.GrimpBody: void printTo(java.io.PrintWriter,int)>|<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.AbstractMap$AbstractEntry: void <init>()>).*<ca.mcgill.sable.util.AbstractMap: java.lang.String toString()>
