.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Collection)><ca.mcgill.sable.soot.jimple.ArrayPackedSet: void add(java.lang.Object,ca.mcgill.sable.soot.jimple.FlowSet)>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void remove()><ca.mcgill.sable.soot.jimple.JasminClass$16: void defaultCase(ca.mcgill.sable.soot.Type)>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$14: void caseAssignStmt(ca.mcgill.sable.soot.jimple.AssignStmt)><java.nio.channels.FileChannel$MapMode: java.lang.String toString()>.*
.*<ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void copy(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JBreakpointStmt: ca.mcgill.sable.util.List getUseBoxes()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: java.lang.Object next()><ca.mcgill.sable.util.IntSet: boolean get(int)>.*
.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.UshrExpr newUshrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.JXorExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>.*
.*<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.Comparator getComparator()><ca.mcgill.sable.soot.coffi.Instruction_Dconst_0: void <init>()>.*
.*<ca.mcgill.sable.util.LinkedList: void <init>()><java.math.MathContext: java.lang.String toString()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: int size()><ca.mcgill.sable.soot.grimp.GShlExpr: void apply(ca.mcgill.sable.util.Switch)>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.TypedSplayTreeMap,ca.mcgill.sable.util.Collection)><ca.mcgill.sable.util.ArraySet: int size()>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()><ca.mcgill.sable.soot.coffi.ClassFile: boolean loadClassFile()>.*
.*<ca.mcgill.sable.soot.AlreadyThrowsException: void <init>(java.lang.String)><ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>.*
.*<ca.mcgill.sable.soot.jimple.JTableSwitchStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void flowThrough(java.lang.Object,ca.mcgill.sable.soot.jimple.Stmt,java.lang.Object)>.*
.*<java.math.BigDecimal: boolean equals(java.lang.Object)><java.text.DigitList: int hashCode()>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: boolean hasNext()><ca.mcgill.sable.soot.jimple.JasminClass$3: void caseIntType(ca.mcgill.sable.soot.IntType)>.*
.*<ca.mcgill.sable.soot.jimple.SparseLocalDefs$LocalStmtPair: int hashCode()><ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getKey()>.*
.*<ca.mcgill.sable.soot.coffi.CONSTANT_Float_info: void <init>()><ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()>.*
.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CmpExpr newCmpExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.TypedLinkedList: void addFirst(java.lang.Object)>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryCollection: int size()><ca.mcgill.sable.soot.jimple.JasminClass$22: void caseByteType(ca.mcgill.sable.soot.ByteType)>.*
.*<ca.mcgill.sable.soot.coffi.CFG: void generateJimple(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[],ca.mcgill.sable.util.List,ca.mcgill.sable.soot.coffi.BasicBlock)><ca.mcgill.sable.soot.SootClass: java.lang.String getName()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: int size()><ca.mcgill.sable.soot.jimple.TypeResolver$ConstraintCollector: void caseNopStmt(ca.mcgill.sable.soot.jimple.NopStmt)>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap: ca.mcgill.sable.util.Collection entries()><ca.mcgill.sable.util.Collections$UnmodListIterator: void set(java.lang.Object)>.*
.*<ca.mcgill.sable.util.ArrayList: boolean contains(java.lang.Object)><java.text.DigitList: java.lang.Object clone()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.coffi.CONSTANT_NameAndType_info: java.lang.String toString(ca.mcgill.sable.soot.coffi.cp_info[])>.*
.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.CaughtExceptionRef newCaughtExceptionRef(ca.mcgill.sable.soot.jimple.JimpleBody)><ca.mcgill.sable.util.TypedSplayTreeMap: ca.mcgill.sable.util.Collection entries()>.*
.*<ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: java.lang.Object newInitialFlow()><ca.mcgill.sable.soot.jimple.JasminClass$36: void caseShortType(ca.mcgill.sable.soot.ShortType)>.*
.*<ca.mcgill.sable.soot.jimple.ForwardFlowAnalysis: void doAnalysis()><ca.mcgill.sable.util.SplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: void <init>(ca.mcgill.sable.util.SplayTreeMap)><ca.mcgill.sable.soot.grimp.Grimp$1: void caseCmpExpr(ca.mcgill.sable.soot.jimple.CmpExpr)>.*
.*<ca.mcgill.sable.soot.jimple.LocalCopy: void <init>(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.jimple.Local)><ca.mcgill.sable.soot.grimp.GXorExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>.*
.*<ca.mcgill.sable.util.SplayTreeMap: int size()><java.security.Timestamp: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()><ca.mcgill.sable.soot.jimple.JasminClass$26: void caseDoubleType(ca.mcgill.sable.soot.DoubleType)>.*
.*<ca.mcgill.sable.soot.coffi.Instruction_Lstore: void <init>()><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: void merge(java.lang.Object,java.lang.Object,java.lang.Object)>.*
.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.OrExpr newOrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>.*
.*<ca.mcgill.sable.soot.jimple.CopiesFlowAnalysis: void copy(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.coffi.CONSTANT_String_info: void <init>()>.*
.*<ca.mcgill.sable.soot.grimp.GInstanceFieldRef: java.lang.String toString()><ca.mcgill.sable.util.TypedSplayTreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>.*
.*<java.math.BigDecimal: java.lang.String toString()><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseNewExpr(ca.mcgill.sable.soot.jimple.NewExpr)>.*
.*<ca.mcgill.sable.soot.baf.BafBody: void <init>(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.jimple.JasminClass$1: void caseShortType(ca.mcgill.sable.soot.ShortType)>.*
.*<ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: java.lang.Object newInitialFlow()><ca.mcgill.sable.util.IntSet: boolean get(int)>.*
.*<java.text.DecimalFormatSymbols: java.lang.Object clone()><sun.misc.FloatingDecimal: void <init>(double)>.*
.*<ca.mcgill.sable.util.SplayTreeMap: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.jimple.ConditionExprBox: void <init>(ca.mcgill.sable.soot.jimple.Value)>.*
.*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.OrExpr newOrExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$35: void caseFloatType(ca.mcgill.sable.soot.FloatType)><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void remove()>.*
.*<ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)><ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.LtExpr newLtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>.*
.*<java.text.DecimalFormatSymbols: int hashCode()><ca.mcgill.sable.soot.jimple.JGotoStmt: void setTarget(ca.mcgill.sable.soot.jimple.Unit)>.*
.*<ca.mcgill.sable.soot.jimple.LocalStmtPair: int hashCode()><ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void remove()>.*
.*<ca.mcgill.sable.soot.grimp.GTableSwitchStmt: void <init>(ca.mcgill.sable.soot.jimple.Value,int,int,ca.mcgill.sable.util.List,ca.mcgill.sable.soot.jimple.Unit)><java.text.DecimalFormatSymbols: java.lang.Object clone()>.*
.*<ca.mcgill.sable.util.SplayTreeMap: java.lang.Object get(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass$17: void caseShlExpr(ca.mcgill.sable.soot.jimple.ShlExpr)>.*
.*<ca.mcgill.sable.util.SplayTreeMap: int size()><ca.mcgill.sable.soot.coffi.Instruction_Putfield: void <init>()>.*
.*<ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: void <init>()><ca.mcgill.sable.util.SplayTreeMap: int size()>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()><ca.mcgill.sable.util.Collections$UnmodList: int hashCode()>.*
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: void ecrAddChild(ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable)><ca.mcgill.sable.util.SplayTreeMap$EntryIterator: java.lang.Object next()>.*
.*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: boolean hasNext()><java.util.StringTokenizer: boolean hasMoreElements()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: boolean hasNext()><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseRefType(ca.mcgill.sable.soot.RefType)>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$23: void caseCharType(ca.mcgill.sable.soot.CharType)><java.math.MathContext: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$18: void caseLongType(ca.mcgill.sable.soot.LongType)><ca.mcgill.sable.util.SplayTreeMap: void <init>(ca.mcgill.sable.util.Map,ca.mcgill.sable.util.Comparator)>.*
.*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int nextIndex()><ca.mcgill.sable.soot.coffi.Instruction_Caload: void <init>()>.*
.*<java.math.MathContext: int hashCode()><ca.mcgill.sable.soot.coffi.Instruction_Astore: void <init>()>.*
.*<ca.mcgill.sable.util.Collections$UnmodList: boolean add(java.lang.Object)><ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)>.*
.*<ca.mcgill.sable.soot.grimp.Grimp: ca.mcgill.sable.soot.jimple.SpecialInvokeExpr newSpecialInvokeExpr(ca.mcgill.sable.soot.jimple.Local,ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.util.List)><java.text.DecimalFormatSymbols: int hashCode()>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$26: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.SplayTreeMap$EntryIterator: java.lang.Object next()>.*
.*<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)><ca.mcgill.sable.util.Collections$UnmodList: ca.mcgill.sable.util.ListIterator listIterator()>.*
.*<ca.mcgill.sable.soot.jimple.AbstractStmt: ca.mcgill.sable.util.List getUseAndDefBoxes()><ca.mcgill.sable.util.TypedSplayTreeMap: ca.mcgill.sable.util.Collection entries()>.*
.*<ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ValueBox newArgBox(ca.mcgill.sable.soot.jimple.Value)><java.math.BigDecimal: java.lang.String toString()>.*
.*<ca.mcgill.sable.util.SplayTreeMap: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JLeExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object getValue()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.GtExpr newGtExpr(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getLeft()><ca.mcgill.sable.util.AbstractMap$ValueCollection: void <init>(ca.mcgill.sable.util.AbstractMap)>.*
.*<ca.mcgill.sable.soot.coffi.Instruction_Getfield: void <init>()><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: int nextIndex()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryIterator: void <init>(ca.mcgill.sable.util.SplayTreeMap)><ca.mcgill.sable.soot.coffi.Instruction_byteindex: int parse(byte[],int)>.*
.*<ca.mcgill.sable.soot.jimple.JThrowStmt: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)>.*
.*<ca.mcgill.sable.soot.jimple.TypeResolver$TypeVariable: boolean setEcrTypeNode(ca.mcgill.sable.soot.jimple.ClassHierarchy$TypeNode)><java.text.DigitList: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getLeft()><ca.mcgill.sable.soot.BooleanType: java.lang.String toString()>.*
.*<ca.mcgill.sable.soot.DeterministicHashMap: void <init>(int,float)><ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: boolean hasNext()>.*
.*<ca.mcgill.sable.soot.coffi.Instruction_Iconst_0: void <init>()><ca.mcgill.sable.soot.baf.BafBody: void printTo(java.io.PrintWriter,int)>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap: ca.mcgill.sable.util.Collection entries()><ca.mcgill.sable.soot.jimple.JasminClass$13: void caseFloatType(ca.mcgill.sable.soot.FloatType)>.*
.*<ca.mcgill.sable.soot.jimple.JimpleBody: void printStatementsInBody(java.io.PrintWriter,boolean)><ca.mcgill.sable.util.SplayTreeMap: java.lang.Object clone()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: void <init>(java.lang.Object,java.lang.Object)><ca.mcgill.sable.soot.jimple.JCmpgExpr: void apply(ca.mcgill.sable.util.Switch)>.*
.*<ca.mcgill.sable.util.AbstractCollection: boolean contains(java.lang.Object)><ca.mcgill.sable.soot.BuildAndStoreBody: ca.mcgill.sable.soot.Body resolveFor(ca.mcgill.sable.soot.SootMethod)>.*
.*<ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)><ca.mcgill.sable.soot.coffi.Instruction_Iload: void <init>()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: void setRight(ca.mcgill.sable.util.SplayTreeMap$Node)><java.util.jar.Attributes: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.util.SplayTreeMap: boolean containsKey(java.lang.Object)><ca.mcgill.sable.soot.jimple.JLtExpr: void apply(ca.mcgill.sable.util.Switch)>.*
.*<ca.mcgill.sable.util.SplayTreeMap$EntryCollection: int size()><ca.mcgill.sable.soot.coffi.Instruction_New: void <init>()>.*
.*<ca.mcgill.sable.util.TypedSplayTreeMap$EntryIterator: java.lang.Object next()><ca.mcgill.sable.soot.jimple.Jimple: ca.mcgill.sable.soot.jimple.ThrowStmt newThrowStmt(ca.mcgill.sable.soot.jimple.Value)>.*
.*<java.math.BigDecimal: java.lang.String toString()><ca.mcgill.sable.soot.coffi.Instruction_Int2byte: void <init>()>.*
.*<java.text.DigitList: java.lang.Object clone()><ca.mcgill.sable.soot.jimple.JasminClass$29: void caseIntType(ca.mcgill.sable.soot.IntType)>.*
.*<ca.mcgill.sable.util.TypedLinkedList$TypedLinkedListIterator: void set(java.lang.Object)><java.text.DecimalFormat: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.soot.coffi.Instruction_Fload_1: void <init>()><ca.mcgill.sable.util.TypedLinkedList: ca.mcgill.sable.util.ListIterator listIterator(int)>.*
.*<ca.mcgill.sable.soot.jimple.ParameterRef: ca.mcgill.sable.util.List getUseBoxes()><java.math.BigDecimal: java.lang.String toString()>.*
.*<ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.Comparator getComparator()><java.util.ResourceBundle$CacheKey: int hashCode()>.*
.*<ca.mcgill.sable.soot.jimple.JasminClass$4: void defaultCase(ca.mcgill.sable.soot.Type)><ca.mcgill.sable.util.SplayTreeMap$EntryCollection: ca.mcgill.sable.util.Iterator iterator()>.*
.*<ca.mcgill.sable.soot.jimple.JThrowStmt: ca.mcgill.sable.util.List getDefBoxes()><java.math.MathContext: java.lang.String toString()>.*
.*<ca.mcgill.sable.soot.grimp.GRemExpr: void <init>(ca.mcgill.sable.soot.jimple.Value,ca.mcgill.sable.soot.jimple.Value)><ca.mcgill.sable.util.SplayTreeMap: ca.mcgill.sable.util.Collection entries()>.*
.*<ca.mcgill.sable.soot.coffi.CFG: ca.mcgill.sable.soot.coffi.OutFlow processFlow(ca.mcgill.sable.soot.coffi.Instruction,ca.mcgill.sable.soot.coffi.TypeStack,ca.mcgill.sable.soot.coffi.cp_info[])><ca.mcgill.sable.soot.ByteType: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.soot.grimp.GAndExpr: void apply(ca.mcgill.sable.util.Switch)><ca.mcgill.sable.soot.jimple.SimpleEqualLocalsAnalysis: java.lang.Object newInitialFlow()>.*
.*<ca.mcgill.sable.util.SplayTreeMap: java.lang.Object get(java.lang.Object)><ca.mcgill.sable.soot.jimple.JasminClass: void emit(java.lang.String)>.*
.*<ca.mcgill.sable.soot.jimple.LocalCopy: int hashCode()><ca.mcgill.sable.soot.jimple.JasminClass$9: void caseNullType(ca.mcgill.sable.soot.NullType)>.*
.*<ca.mcgill.sable.util.AbstractMap: java.lang.Object put(java.lang.Object,java.lang.Object)><ca.mcgill.sable.util.SplayTreeMap$Node: ca.mcgill.sable.util.SplayTreeMap$Node getRight()>.*
.*<ca.mcgill.sable.util.SplayTreeMap$Node: java.lang.Object setValue(java.lang.Object)><java.util.jar.Manifest: boolean equals(java.lang.Object)>.*
.*<ca.mcgill.sable.soot.baf.Baf: ca.mcgill.sable.soot.Body buildBodyOfFrom(ca.mcgill.sable.soot.SootMethod,ca.mcgill.sable.soot.Body,int)><ca.mcgill.sable.soot.coffi.LocalVariableTable_attribute: java.lang.String getLocalVariableName(ca.mcgill.sable.soot.coffi.cp_info[],int)>.*
